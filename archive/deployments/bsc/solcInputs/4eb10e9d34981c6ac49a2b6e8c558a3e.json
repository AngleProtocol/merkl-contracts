{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with\n * a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\n * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20 private immutable _asset;\n    uint8 private immutable _decimals;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _decimals = success ? assetDecimals : super.decimals();\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}.\n     *\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\n     * In this case, the shares will be minted without requiring any assets to be deposited.\n     */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amount of shares.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? _initialConvertToShares(assets, rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\n     */\n    function _initialConvertToShares(\n        uint256 assets,\n        Math.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 shares) {\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\n     */\n    function _initialConvertToAssets(\n        uint256 shares,\n        Math.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 assets) {\n        return shares;\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.\n     */\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/deprecated/OldDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../utils/UUPSHelper.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are `(address user, address token, uint amount)`\n    // representing an amount of tokens accumulated by `user`.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\nstruct Claim {\n    uint208 amount;\n    uint48 timestamp;\n    bytes32 merkleRoot;\n}\n\n/// @title Distributor\n/// @notice Allows LPs on AMMs with concentrated liquidity to claim the rewards that were distributed to them\n/// @author Angle Labs. Inc\ncontract OldDistributor is UUPSHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice Epoch duration\n    uint32 internal constant _EPOCH_DURATION = 3600;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Tree that was in place in the contract before the last `tree` update\n    MerkleTree public lastTree;\n\n    /// @notice Token to deposit to freeze the roots update\n    IERC20 public disputeToken;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice Address which created the dispute\n    /// @dev Used to store if there is an ongoing dispute\n    address public disputer;\n\n    /// @notice When the current tree will become valid\n    uint48 public endOfDisputePeriod;\n\n    /// @notice Time after which a change in a tree becomes effective, in EPOCH_DURATION\n    uint48 public disputePeriod;\n\n    /// @notice Amount to deposit to freeze the roots update\n    uint256 public disputeAmount;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => Claim)) public claimed;\n\n    /// @notice Trusted EOAs to update the Merkle root\n    mapping(address => uint256) public canUpdateMerkleRoot;\n\n    /// @notice Whether or not to disable permissionless claiming\n    mapping(address => uint256) public onlyOperatorCanClaim;\n\n    /// @notice user -> operator -> authorisation to claim\n    mapping(address => mapping(address => uint256)) public operators;\n\n    uint256[38] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event Claimed(address indexed user, address indexed token, uint256 amount);\n    event DisputeAmountUpdated(uint256 _disputeAmount);\n    event Disputed(string reason);\n    event DisputePeriodUpdated(uint48 _disputePeriod);\n    event DisputeResolved(bool valid);\n    event DisputeTokenUpdated(address indexed _disputeToken);\n    event OperatorClaimingToggled(address indexed user, bool isEnabled);\n    event OperatorToggled(address indexed user, address indexed operator, bool isWhitelisted);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event Revoked(); // With this event an indexer could maintain a table (timestamp, merkleRootUpdate)\n    event TreeUpdated(bytes32 merkleRoot, bytes32 ipfsHash, uint48 endOfDisputePeriod);\n    event TrustedToggled(address indexed eoa, bool trust);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is the `user` address or is a trusted address\n    modifier onlyTrustedOrUser(address user) {\n        if (user != msg.sender && canUpdateMerkleRoot[msg.sender] != 1 && !core.isGovernorOrGuardian(msg.sender))\n            revert NotTrusted();\n        _;\n    }\n\n    // ================================ CONSTRUCTOR ================================\n\n    constructor() initializer {}\n\n    function initialize(ICore _core) external initializer {\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGuardianUpgrader(core) {}\n\n    // =============================== MAIN FUNCTION ===============================\n\n    /// @notice Claims rewards for a given set of users\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// who provides the proof and pays the gas: `msg.sender` is used only for addresses that require a trusted operator\n    /// @param users Recipient of tokens\n    /// @param tokens ERC20 claimed\n    /// @param amounts Amount of tokens that will be sent to the corresponding users\n    /// @param proofs Array of hashes bridging from a leaf `(hash of user | token | amount)` to the Merkle root\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external {\n        uint256 usersLength = users.length;\n        if (\n            usersLength == 0 ||\n            usersLength != tokens.length ||\n            usersLength != amounts.length ||\n            usersLength != proofs.length\n        ) revert InvalidLengths();\n\n        for (uint256 i; i < usersLength; ) {\n            address user = users[i];\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n\n            // Checking if only an approved operator can claim for `user`\n            if (onlyOperatorCanClaim[user] == 1 && operators[user][msg.sender] == 0) revert NotWhitelisted();\n\n            // Verifying proof\n            bytes32 leaf = keccak256(abi.encode(user, token, amount));\n            if (!_verifyProof(leaf, proofs[i])) revert InvalidProof();\n\n            // Closing reentrancy gate here\n            uint256 toSend = amount - claimed[user][token].amount;\n            claimed[user][token] = Claim(SafeCast.toUint208(amount), uint48(block.timestamp), getMerkleRoot());\n\n            IERC20(token).safeTransfer(user, toSend);\n            emit Claimed(user, token, toSend);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the MerkleRoot that is currently live for the contract\n    function getMerkleRoot() public view returns (bytes32) {\n        if (block.timestamp >= endOfDisputePeriod && disputer == address(0)) return tree.merkleRoot;\n        else return lastTree.merkleRoot;\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Adds or removes EOAs which are trusted to update the Merkle root\n    function toggleTrusted(address eoa) external onlyGovernorOrGuardian {\n        uint256 trustedStatus = 1 - canUpdateMerkleRoot[eoa];\n        canUpdateMerkleRoot[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @notice Updates Merkle Tree\n    function updateTree(MerkleTree calldata _tree) external {\n        if (\n            disputer != address(0) ||\n            // A trusted address cannot update a tree right after a precedent tree update otherwise it can de facto\n            // validate a tree which has not passed the dispute period\n            ((canUpdateMerkleRoot[msg.sender] != 1 || block.timestamp < endOfDisputePeriod) &&\n                !core.isGovernorOrGuardian(msg.sender))\n        ) revert NotTrusted();\n        MerkleTree memory _lastTree = tree;\n        tree = _tree;\n        lastTree = _lastTree;\n\n        uint48 _endOfPeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        endOfDisputePeriod = _endOfPeriod;\n        emit TreeUpdated(_tree.merkleRoot, _tree.ipfsHash, _endOfPeriod);\n    }\n\n    /// @notice Freezes the Merkle tree update until the dispute is resolved\n    /// @dev Requires a deposit of `disputeToken` that'll be slashed if the dispute is not accepted\n    /// @dev It is only possible to create a dispute within `disputePeriod` after each tree update\n    function disputeTree(string memory reason) external {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();\n        IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);\n        disputer = msg.sender;\n        emit Disputed(reason);\n    }\n\n    /// @notice Resolve the ongoing dispute, if any\n    /// @param valid Whether the dispute was valid\n    function resolveDispute(bool valid) external onlyGovernorOrGuardian {\n        if (disputer == address(0)) revert NoDispute();\n        if (valid) {\n            IERC20(disputeToken).safeTransfer(disputer, disputeAmount);\n            // If a dispute is valid, the contract falls back to the last tree that was updated\n            _revokeTree();\n        } else {\n            IERC20(disputeToken).safeTransfer(msg.sender, disputeAmount);\n            endOfDisputePeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        }\n        disputer = address(0);\n        emit DisputeResolved(valid);\n    }\n\n    /// @notice Allows the governor or the guardian of this contract to fallback to the last version of the tree\n    /// immediately\n    function revokeTree() external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        _revokeTree();\n    }\n\n    /// @notice Toggles permissioned claiming for a given user\n    function toggleOnlyOperatorCanClaim(address user) external onlyTrustedOrUser(user) {\n        uint256 oldValue = onlyOperatorCanClaim[user];\n        onlyOperatorCanClaim[user] = 1 - oldValue;\n        emit OperatorClaimingToggled(user, oldValue == 0);\n    }\n\n    /// @notice Toggles whitelisting for a given user and a given operator\n    function toggleOperator(address user, address operator) external onlyTrustedOrUser(user) {\n        uint256 oldValue = operators[user][operator];\n        operators[user][operator] = 1 - oldValue;\n        emit OperatorToggled(user, operator, oldValue == 0);\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernorOrGuardian {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Sets the dispute period after which a tree update becomes effective\n    function setDisputePeriod(uint48 _disputePeriod) external onlyGovernorOrGuardian {\n        disputePeriod = uint48(_disputePeriod);\n        emit DisputePeriodUpdated(_disputePeriod);\n    }\n\n    /// @notice Sets the token used as a caution during disputes\n    function setDisputeToken(IERC20 _disputeToken) external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeToken = _disputeToken;\n        emit DisputeTokenUpdated(address(_disputeToken));\n    }\n\n    /// @notice Sets the amount of `disputeToken` used as a caution during disputes\n    function setDisputeAmount(uint256 _disputeAmount) external onlyGovernorOrGuardian {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeAmount = _disputeAmount;\n        emit DisputeAmountUpdated(_disputeAmount);\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Fallback to the last version of the tree\n    function _revokeTree() internal {\n        MerkleTree memory _tree = lastTree;\n        endOfDisputePeriod = 0;\n        tree = _tree;\n        emit Revoked();\n        emit TreeUpdated(\n            _tree.merkleRoot,\n            _tree.ipfsHash,\n            (uint48(block.timestamp) / _EPOCH_DURATION) * (_EPOCH_DURATION) // Last hour\n        );\n    }\n\n    /// @notice Returns the end of the dispute period\n    /// @dev treeUpdate is rounded up to next hour and then `disputePeriod` hours are added\n    function _endOfDisputePeriod(uint48 treeUpdate) internal view returns (uint48) {\n        return ((treeUpdate - 1) / _EPOCH_DURATION + 1 + disputePeriod) * (_EPOCH_DURATION);\n    }\n\n    /// @notice Checks the validity of a proof\n    /// @param leaf Hashed leaf data, the starting point of the proof\n    /// @param proof Array of hashes forming a hash chain from leaf to root\n    /// @return true If proof is correct, else false\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        bytes32 currentHash = leaf;\n        uint256 proofLength = proof.length;\n        for (uint256 i; i < proofLength; ) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        bytes32 root = getMerkleRoot();\n        if (root == bytes32(0)) revert InvalidUninitializedRoot();\n        return currentHash == root;\n    }\n}\n"
    },
    "contracts/DistributionCreator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { IUniswapV3Pool } from \"./interfaces/external/uniswap/IUniswapV3Pool.sol\";\n\nimport \"./utils/UUPSHelper.sol\";\nimport { CampaignParameters } from \"./struct/CampaignParameters.sol\";\nimport { DistributionParameters } from \"./struct/DistributionParameters.sol\";\nimport { RewardTokenAmounts } from \"./struct/RewardTokenAmounts.sol\";\n\n/// @title DistributionCreator\n/// @author Angle Labs, Inc.\n/// @notice Manages the distribution of rewards through the Merkl system\n/// @dev This contract is mostly a helper for APIs built on top of Merkl\n/// @dev This contract is an upgraded version and distinguishes two types of different rewards:\n/// - distributions: type of campaign for concentrated liquidity pools created before Feb 15 2024,\n/// now deprecated\n/// - campaigns: the new more global name to describe any reward program on top of Merkl\n//solhint-disable\ncontract DistributionCreator is UUPSHelper, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 CONSTANTS / VARIABLES                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    uint32 public constant HOUR = 3600;\n\n    /// @notice Base for fee computation\n    uint256 public constant BASE_9 = 1e9;\n\n    uint256 public immutable CHAIN_ID = block.chainid;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice Contract distributing rewards to users\n    address public distributor;\n\n    /// @notice Address to which fees are forwarded\n    address public feeRecipient;\n\n    /// @notice Value (in base 10**9) of the fees taken when creating a campaign\n    uint256 public defaultFees;\n\n    /// @notice Message that needs to be acknowledged by users creating a campaign\n    string public message;\n\n    /// @notice Hash of the message that needs to be signed\n    bytes32 public messageHash;\n\n    /// @notice List of all rewards distributed in the contract on campaigns created before mid Feb 2024\n    /// for concentrated liquidity pools\n    DistributionParameters[] public distributionList;\n\n    /// @notice Maps an address to its fee rebate\n    mapping(address => uint256) public feeRebate;\n\n    /// @notice Maps a token to whether it is whitelisted or not. No fees are to be paid for incentives given\n    /// on pools with whitelisted tokens\n    mapping(address => uint256) public isWhitelistedToken;\n\n    /// @notice Deprecated, kept for storage compatibility\n    mapping(address => uint256) public _nonces;\n\n    /// @notice Maps an address to the last valid hash signed\n    mapping(address => bytes32) public userSignatures;\n\n    /// @notice Maps a user to whether it is whitelisted for not signing\n    mapping(address => uint256) public userSignatureWhitelist;\n\n    /// @notice Maps a token to the minimum amount that must be sent per epoch for a distribution to be valid\n    /// @dev If `rewardTokenMinAmounts[token] == 0`, then `token` cannot be used as a reward\n    mapping(address => uint256) public rewardTokenMinAmounts;\n\n    /// @notice List of all reward tokens that have at some point been accepted\n    address[] public rewardTokens;\n\n    /// @notice List of all rewards ever distributed or to be distributed in the contract\n    /// @dev An attacker could try to populate this list. It shouldn't be an issue as only view functions\n    /// iterate on it\n    CampaignParameters[] public campaignList;\n\n    /// @notice Maps a campaignId to the ID of the campaign in the campaign list + 1\n    mapping(bytes32 => uint256) internal _campaignLookup;\n\n    /// @notice Maps a campaign type to the fees for this specific campaign\n    mapping(uint32 => uint256) public campaignSpecificFees;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        EVENTS                                                      \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    event DistributorUpdated(address indexed _distributor);\n    event FeeRebateUpdated(address indexed user, uint256 userFeeRebate);\n    event FeeRecipientUpdated(address indexed _feeRecipient);\n    event FeesSet(uint256 _fees);\n    event CampaignSpecificFeesSet(uint32 campaignType, uint256 _fees);\n    event MessageUpdated(bytes32 _messageHash);\n    event NewCampaign(CampaignParameters campaign);\n    event NewDistribution(DistributionParameters distribution, address indexed sender);\n    event RewardTokenMinimumAmountUpdated(address indexed token, uint256 amount);\n    event TokenWhitelistToggled(address indexed token, uint256 toggleStatus);\n    event UserSigned(bytes32 messageHash, address indexed user);\n    event UserSigningWhitelistToggled(address indexed user, uint256 toggleStatus);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       MODIFIERS                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether an address has signed the message or not\n    modifier hasSigned() {\n        if (\n            userSignatureWhitelist[msg.sender] == 0 &&\n            userSignatures[msg.sender] != messageHash &&\n            userSignatureWhitelist[tx.origin] == 0 &&\n            userSignatures[tx.origin] != messageHash\n        ) revert NotSigned();\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      CONSTRUCTOR                                                   \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    function initialize(ICore _core, address _distributor, uint256 _fees) external initializer {\n        if (address(_core) == address(0) || _distributor == address(0)) revert ZeroAddress();\n        if (_fees >= BASE_9) revert InvalidParam();\n        distributor = _distributor;\n        core = _core;\n        defaultFees = _fees;\n    }\n\n    constructor() initializer {}\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGovernorUpgrader(core) {}\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 USER FACING FUNCTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a `campaign` to incentivize a given pool for a specific period of time\n    /// @return The campaignId of the new campaign\n    /// @dev If the campaign is badly specified, it will not be handled by the campaign script and rewards may be lost\n    /// @dev Reward tokens sent as part of campaigns must have been whitelisted before and amounts\n    /// sent should be bigger than a minimum amount specific to each token\n    /// @dev This function reverts if the sender has not accepted the terms and conditions\n    function createCampaign(CampaignParameters memory newCampaign) external nonReentrant hasSigned returns (bytes32) {\n        return _createCampaign(newCampaign);\n    }\n\n    /// @notice Same as the function above but for multiple campaigns at once\n    /// @return List of all the campaign amounts actually deposited for each `campaign` in the `campaigns` list\n    function createCampaigns(\n        CampaignParameters[] memory campaigns\n    ) external nonReentrant hasSigned returns (bytes32[] memory) {\n        uint256 campaignsLength = campaigns.length;\n        bytes32[] memory campaignIds = new bytes32[](campaignsLength);\n        for (uint256 i; i < campaignsLength; ) {\n            campaignIds[i] = _createCampaign(campaigns[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return campaignIds;\n    }\n\n    /// @notice Allows a user to accept the conditions without signing the message\n    /// @dev Users may either call `acceptConditions` here or `sign` the message\n    function acceptConditions() external {\n        userSignatureWhitelist[msg.sender] = 1;\n    }\n\n    /// @notice Checks whether the `msg.sender`'s `signature` is compatible with the message\n    /// to sign and stores the signature\n    /// @dev If you signed the message once, and the message has not been modified, then you do not\n    /// need to sign again\n    function sign(bytes calldata signature) external {\n        _sign(signature);\n    }\n\n    /// @notice Combines signing the message and creating a campaign\n    function signAndCreateCampaign(\n        CampaignParameters memory newCampaign,\n        bytes calldata signature\n    ) external returns (bytes32) {\n        _sign(signature);\n        return _createCampaign(newCampaign);\n    }\n\n    /// @notice Creates a `distribution` to incentivize a given pool for a specific period of time\n    function createDistribution(\n        DistributionParameters memory newDistribution\n    ) external nonReentrant hasSigned returns (uint256 distributionAmount) {\n        return _createDistribution(newDistribution);\n    }\n\n    /// @notice Same as the function above but for multiple distributions at once\n    function createDistributions(\n        DistributionParameters[] memory distributions\n    ) external nonReentrant hasSigned returns (uint256[] memory) {\n        uint256 distributionsLength = distributions.length;\n        uint256[] memory distributionAmounts = new uint256[](distributionsLength);\n        for (uint256 i; i < distributionsLength; ) {\n            distributionAmounts[i] = _createDistribution(distributions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return distributionAmounts;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        GETTERS                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the distribution at a given index converted into a campaign\n    function distribution(uint256 index) external view returns (CampaignParameters memory) {\n        return _convertDistribution(distributionList[index]);\n    }\n\n    /// @notice Returns the index of a campaign in the campaign list\n    function campaignLookup(bytes32 _campaignId) public view returns (uint256) {\n        uint256 index = _campaignLookup[_campaignId];\n        if (index == 0) revert CampaignDoesNotExist();\n        return index - 1;\n    }\n\n    /// @notice Returns the campaign parameters of a given campaignId\n    function campaign(bytes32 _campaignId) external view returns (CampaignParameters memory) {\n        return campaignList[campaignLookup(_campaignId)];\n    }\n\n    /// @notice Returns the campaign ID for a given campaign\n    /// @dev The campaign ID is computed as the hash of the following parameters:\n    ///  - `campaign.creator`\n    ///  - `campaign.rewardToken`\n    ///  - `campaign.campaignType`\n    ///  - `campaign.startTimestamp`\n    ///  - `campaign.duration`\n    ///  - `campaign.campaignData`\n    /// This prevents the creation by the same account of two campaigns with the same parameters\n    /// which is not a huge issue\n    function campaignId(CampaignParameters memory campaignData) public view returns (bytes32) {\n        return\n            bytes32(\n                keccak256(\n                    abi.encodePacked(\n                        CHAIN_ID,\n                        campaignData.creator,\n                        campaignData.rewardToken,\n                        campaignData.campaignType,\n                        campaignData.startTimestamp,\n                        campaignData.duration,\n                        campaignData.campaignData\n                    )\n                )\n            );\n    }\n\n    /// @notice Returns the list of all the reward tokens supported as well as their minimum amounts\n    /// @dev Not to be queried on-chain and hence not optimized for gas consumption\n    function getValidRewardTokens() external view returns (RewardTokenAmounts[] memory) {\n        (RewardTokenAmounts[] memory validRewardTokens, ) = _getValidRewardTokens(0, type(uint32).max);\n        return validRewardTokens;\n    }\n\n    /// @dev Not to be queried on-chain and hence not optimized for gas consumption\n    function getValidRewardTokens(\n        uint32 skip,\n        uint32 first\n    ) external view returns (RewardTokenAmounts[] memory, uint256) {\n        return _getValidRewardTokens(skip, first);\n    }\n\n    /// @notice Gets all the campaigns which were live at some point between `start` and `end` timestamp\n    /// @param skip Disregard distibutions with a global index lower than `skip`\n    /// @param first Limit the length of the returned array to `first`\n    /// @return searchCampaigns Eligible campaigns\n    /// @return lastIndexCampaign Index of the last campaign assessed in the list of all campaigns\n    /// @dev For pagniation purpose, in case of out of gas, you can call back the same function but with `skip` set to `lastIndexCampaign`\n    /// @dev Not to be queried on-chain and hence not optimized for gas consumption\n    function getCampaignsBetween(\n        uint32 start,\n        uint32 end,\n        uint32 skip,\n        uint32 first\n    ) external view returns (CampaignParameters[] memory, uint256 lastIndexCampaign) {\n        return _getCampaignsBetween(start, end, skip, first);\n    }\n\n    /// @notice Gets all the distributions which were live at some point between `start` and `end` timestamp\n    /// @param skip Disregard distibutions with a global index lower than `skip`\n    /// @param first Limit the length of the returned array to `first`\n    /// @return searchDistributions Eligible distributions\n    /// @return lastIndexDistribution Index of the last distribution assessed in the list of all distributions\n    /// @dev For pagniation purpose, in case of out of gas, you can call back the same function but with `skip` set to `lastIndexDistribution`\n    /// @dev Not to be queried on-chain and hence not optimized for gas consumption\n    function getDistributionsBetweenEpochs(\n        uint32 epochStart,\n        uint32 epochEnd,\n        uint32 skip,\n        uint32 first\n    ) external view returns (DistributionParameters[] memory, uint256 lastIndexDistribution) {\n        return _getDistributionsBetweenEpochs(_getRoundedEpoch(epochStart), _getRoundedEpoch(epochEnd), skip, first);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 GOVERNANCE FUNCTIONS                                               \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets a new `distributor` to which rewards should be distributed\n    function setNewDistributor(address _distributor) external onlyGovernor {\n        if (_distributor == address(0)) revert InvalidParam();\n        distributor = _distributor;\n        emit DistributorUpdated(_distributor);\n    }\n\n    /// @notice Sets the defaultFees on deposit\n    function setFees(uint256 _defaultFees) external onlyGovernor {\n        if (_defaultFees >= BASE_9) revert InvalidParam();\n        defaultFees = _defaultFees;\n        emit FeesSet(_defaultFees);\n    }\n\n    /// @notice Sets the fees specific for a campaign\n    /// @dev To waive the fees for a campaign, set its fees to 1\n    function setCampaignFees(uint32 campaignType, uint256 _fees) external onlyGovernorOrGuardian {\n        if (_fees >= BASE_9) revert InvalidParam();\n        campaignSpecificFees[campaignType] = _fees;\n        emit CampaignSpecificFeesSet(campaignType, _fees);\n    }\n\n    /// @notice Toggles the fee whitelist for `token`\n    function toggleTokenWhitelist(address token) external onlyGovernorOrGuardian {\n        uint256 toggleStatus = 1 - isWhitelistedToken[token];\n        isWhitelistedToken[token] = toggleStatus;\n        emit TokenWhitelistToggled(token, toggleStatus);\n    }\n\n    /// @notice Recovers fees accrued on the contract for a list of `tokens`\n    function recoverFees(IERC20[] calldata tokens, address to) external onlyGovernor {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i < tokensLength; ) {\n            tokens[i].safeTransfer(to, tokens[i].balanceOf(address(this)));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Sets fee rebates for a given user\n    function setUserFeeRebate(address user, uint256 userFeeRebate) external onlyGovernorOrGuardian {\n        feeRebate[user] = userFeeRebate;\n        emit FeeRebateUpdated(user, userFeeRebate);\n    }\n\n    /// @notice Sets the minimum amounts per distribution epoch for different reward tokens\n    function setRewardTokenMinAmounts(\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external onlyGovernorOrGuardian {\n        uint256 tokensLength = tokens.length;\n        if (tokensLength != amounts.length) revert InvalidLengths();\n        for (uint256 i; i < tokensLength; ++i) {\n            uint256 amount = amounts[i];\n            // Basic logic check to make sure there are no duplicates in the `rewardTokens` table. If a token is\n            // removed then re-added, it will appear as a duplicate in the list\n            if (amount > 0 && rewardTokenMinAmounts[tokens[i]] == 0) rewardTokens.push(tokens[i]);\n            rewardTokenMinAmounts[tokens[i]] = amount;\n            emit RewardTokenMinimumAmountUpdated(tokens[i], amount);\n        }\n    }\n\n    /// @notice Sets a new address to receive fees\n    function setFeeRecipient(address _feeRecipient) external onlyGovernor {\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /// @notice Sets the message that needs to be signed by users before posting rewards\n    function setMessage(string memory _message) external onlyGovernor {\n        message = _message;\n        bytes32 _messageHash = ECDSA.toEthSignedMessageHash(bytes(_message));\n        messageHash = _messageHash;\n        emit MessageUpdated(_messageHash);\n    }\n\n    /// @notice Toggles the whitelist status for `user` when it comes to signing messages before depositing rewards.\n    function toggleSigningWhitelist(address user) external onlyGovernorOrGuardian {\n        uint256 whitelistStatus = 1 - userSignatureWhitelist[user];\n        userSignatureWhitelist[user] = whitelistStatus;\n        emit UserSigningWhitelistToggled(user, whitelistStatus);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                       INTERNAL                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal version of `createCampaign`\n    function _createCampaign(CampaignParameters memory newCampaign) internal returns (bytes32) {\n        uint256 rewardTokenMinAmount = rewardTokenMinAmounts[newCampaign.rewardToken];\n        // if epoch parameters lead to a past campaign\n        if (newCampaign.startTimestamp < block.timestamp) revert CampaignSouldStartInFuture();\n        // if the campaign doesn't last at least one hour\n        if (newCampaign.duration < HOUR) revert CampaignDurationBelowHour();\n        // if the reward token is not whitelisted as an incentive token\n        if (rewardTokenMinAmount == 0) revert CampaignRewardTokenNotWhitelisted();\n        // if the amount distributed is too small with respect to what is allowed\n        if ((newCampaign.amount * HOUR) / newCampaign.duration < rewardTokenMinAmount) revert CampaignRewardTooLow();\n\n        if (newCampaign.creator == address(0)) newCampaign.creator = msg.sender;\n\n        // Computing fees: these are waived for whitelisted addresses and if there is a whitelisted token in a pool\n        uint256 _fees = campaignSpecificFees[newCampaign.campaignType];\n        if (_fees == 1) _fees = 0;\n        else if (_fees == 0) _fees = defaultFees;\n        uint256 campaignAmountMinusFees = _computeFees(_fees, newCampaign.amount, newCampaign.rewardToken);\n        newCampaign.amount = campaignAmountMinusFees;\n\n        newCampaign.campaignId = campaignId(newCampaign);\n\n        if (_campaignLookup[newCampaign.campaignId] != 0) revert CampaignAlreadyExists();\n        _campaignLookup[newCampaign.campaignId] = campaignList.length + 1;\n        campaignList.push(newCampaign);\n        emit NewCampaign(newCampaign);\n\n        return newCampaign.campaignId;\n    }\n\n    /// @notice Creates a distribution from a deprecated distribution type\n    function _createDistribution(DistributionParameters memory newDistribution) internal returns (uint256) {\n        _createCampaign(_convertDistribution(newDistribution));\n        // Not gas efficient but deprecated\n        return campaignList[campaignList.length - 1].amount;\n    }\n\n    /// @notice Converts the deprecated distribution type into a campaign\n    function _convertDistribution(\n        DistributionParameters memory distributionToConvert\n    ) internal view returns (CampaignParameters memory) {\n        uint256 wrapperLength = distributionToConvert.wrapperTypes.length;\n        address[] memory whitelist = new address[](wrapperLength);\n        address[] memory blacklist = new address[](wrapperLength);\n        uint256 whitelistLength;\n        uint256 blacklistLength;\n        for (uint256 k = 0; k < wrapperLength; k++) {\n            if (distributionToConvert.wrapperTypes[k] == 0) {\n                whitelist[whitelistLength] = (distributionToConvert.positionWrappers[k]);\n                whitelistLength += 1;\n            }\n            if (distributionToConvert.wrapperTypes[k] == 3) {\n                blacklist[blacklistLength] = (distributionToConvert.positionWrappers[k]);\n                blacklistLength += 1;\n            }\n        }\n\n        assembly {\n            mstore(whitelist, whitelistLength)\n            mstore(blacklist, blacklistLength)\n        }\n\n        return\n            CampaignParameters({\n                campaignId: distributionToConvert.rewardId,\n                creator: msg.sender,\n                rewardToken: distributionToConvert.rewardToken,\n                amount: distributionToConvert.amount,\n                campaignType: 2,\n                startTimestamp: distributionToConvert.epochStart,\n                duration: distributionToConvert.numEpoch * HOUR,\n                campaignData: abi.encode(\n                    distributionToConvert.uniV3Pool,\n                    distributionToConvert.propFees, // eg. 6000\n                    distributionToConvert.propToken0, // eg. 3000\n                    distributionToConvert.propToken1, // eg. 1000\n                    distributionToConvert.isOutOfRangeIncentivized, // eg. 0\n                    distributionToConvert.boostingAddress, // eg. NULL_ADDRESS\n                    distributionToConvert.boostedReward, // eg. 0\n                    whitelist, // eg. []\n                    blacklist, // eg. []\n                    \"0x\"\n                )\n            });\n    }\n\n    /// @notice Computes the fees to be taken on a campaign and transfers them to the fee recipient\n    function _computeFees(\n        uint256 baseFeesValue,\n        uint256 distributionAmount,\n        address rewardToken\n    ) internal returns (uint256 distributionAmountMinusFees) {\n        uint256 _fees = (baseFeesValue * (BASE_9 - feeRebate[msg.sender])) / BASE_9;\n        distributionAmountMinusFees = distributionAmount;\n        if (_fees != 0) {\n            distributionAmountMinusFees = (distributionAmount * (BASE_9 - _fees)) / BASE_9;\n            address _feeRecipient = feeRecipient;\n            _feeRecipient = _feeRecipient == address(0) ? address(this) : _feeRecipient;\n            IERC20(rewardToken).safeTransferFrom(\n                msg.sender,\n                _feeRecipient,\n                distributionAmount - distributionAmountMinusFees\n            );\n        }\n        IERC20(rewardToken).safeTransferFrom(msg.sender, distributor, distributionAmountMinusFees);\n    }\n\n    /// @notice Internal version of the `sign` function\n    function _sign(bytes calldata signature) internal {\n        bytes32 _messageHash = messageHash;\n        if (!SignatureChecker.isValidSignatureNow(msg.sender, _messageHash, signature)) revert InvalidSignature();\n        userSignatures[msg.sender] = _messageHash;\n        emit UserSigned(_messageHash, msg.sender);\n    }\n\n    /// @notice Rounds an `epoch` timestamp to the start of the corresponding period\n    function _getRoundedEpoch(uint32 epoch) internal pure returns (uint32) {\n        return (epoch / HOUR) * HOUR;\n    }\n\n    /// @notice Internal version of `getCampaignsBetween`\n    function _getCampaignsBetween(\n        uint32 start,\n        uint32 end,\n        uint32 skip,\n        uint32 first\n    ) internal view returns (CampaignParameters[] memory, uint256) {\n        uint256 length;\n        uint256 campaignListLength = campaignList.length;\n        uint256 returnSize = first > campaignListLength ? campaignListLength : first;\n        CampaignParameters[] memory activeRewards = new CampaignParameters[](returnSize);\n        uint32 i = skip;\n        while (i < campaignListLength) {\n            CampaignParameters memory campaignToProcess = campaignList[i];\n            if (\n                campaignToProcess.startTimestamp + campaignToProcess.duration > start &&\n                campaignToProcess.startTimestamp < end\n            ) {\n                activeRewards[length] = campaignToProcess;\n                length += 1;\n            }\n            unchecked {\n                ++i;\n            }\n            if (length == returnSize) break;\n        }\n        assembly {\n            mstore(activeRewards, length)\n        }\n        return (activeRewards, i);\n    }\n\n    /// @notice Internal version of `getDistributionsBetweenEpochs`\n    function _getDistributionsBetweenEpochs(\n        uint32 epochStart,\n        uint32 epochEnd,\n        uint32 skip,\n        uint32 first\n    ) internal view returns (DistributionParameters[] memory, uint256) {\n        uint256 length;\n        uint256 distributionListLength = distributionList.length;\n        uint256 returnSize = first > distributionListLength ? distributionListLength : first;\n        DistributionParameters[] memory activeRewards = new DistributionParameters[](returnSize);\n        uint32 i = skip;\n        while (i < distributionListLength) {\n            DistributionParameters memory d = distributionList[i];\n            if (d.epochStart + d.numEpoch * HOUR > epochStart && d.epochStart < epochEnd) {\n                activeRewards[length] = d;\n                length += 1;\n            }\n            unchecked {\n                ++i;\n            }\n            if (length == returnSize) break;\n        }\n        assembly {\n            mstore(activeRewards, length)\n        }\n        return (activeRewards, i);\n    }\n\n    /// @notice Builds the list of valid reward tokens\n    function _getValidRewardTokens(\n        uint32 skip,\n        uint32 first\n    ) internal view returns (RewardTokenAmounts[] memory, uint256) {\n        uint256 length;\n        uint256 rewardTokenListLength = rewardTokens.length;\n        uint256 returnSize = first > rewardTokenListLength ? rewardTokenListLength : first;\n        RewardTokenAmounts[] memory validRewardTokens = new RewardTokenAmounts[](returnSize);\n        uint32 i = skip;\n        while (i < rewardTokenListLength) {\n            address token = rewardTokens[i];\n            uint256 minAmount = rewardTokenMinAmounts[token];\n            if (minAmount > 0) {\n                validRewardTokens[length] = RewardTokenAmounts(token, minAmount);\n                length += 1;\n            }\n            unchecked {\n                ++i;\n            }\n            if (length == returnSize) break;\n        }\n        assembly {\n            mstore(validRewardTokens, length)\n        }\n        return (validRewardTokens, i);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[33] private __gap;\n}\n"
    },
    "contracts/Distributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./utils/UUPSHelper.sol\";\n\nstruct MerkleTree {\n    // Root of a Merkle tree which leaves are `(address user, address token, uint amount)`\n    // representing an amount of tokens accumulated by `user`.\n    // The Merkle tree is assumed to have only increasing amounts: that is to say if a user can claim 1,\n    // then after the amount associated in the Merkle tree for this token should be x > 1\n    bytes32 merkleRoot;\n    // Ipfs hash of the tree data\n    bytes32 ipfsHash;\n}\n\nstruct Claim {\n    uint208 amount;\n    uint48 timestamp;\n    bytes32 merkleRoot;\n}\n\n/// @title Distributor\n/// @notice Allows to claim rewards distributed to them through Merkl\n/// @author Angle Labs. Inc\ncontract Distributor is UUPSHelper {\n    using SafeERC20 for IERC20;\n\n    /// @notice Epoch duration\n    uint32 internal constant _EPOCH_DURATION = 3600;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice Tree of claimable tokens through this contract\n    MerkleTree public tree;\n\n    /// @notice Tree that was in place in the contract before the last `tree` update\n    MerkleTree public lastTree;\n\n    /// @notice Token to deposit to freeze the roots update\n    IERC20 public disputeToken;\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    /// @notice Address which created the dispute\n    /// @dev Used to store if there is an ongoing dispute\n    address public disputer;\n\n    /// @notice When the current tree will become valid\n    uint48 public endOfDisputePeriod;\n\n    /// @notice Time after which a change in a tree becomes effective, in EPOCH_DURATION\n    uint48 public disputePeriod;\n\n    /// @notice Amount to deposit to freeze the roots update\n    uint256 public disputeAmount;\n\n    /// @notice Mapping user -> token -> amount to track claimed amounts\n    mapping(address => mapping(address => Claim)) public claimed;\n\n    /// @notice Trusted EOAs to update the Merkle root\n    mapping(address => uint256) public canUpdateMerkleRoot;\n\n    /// @notice Whether or not to disable permissionless claiming\n    mapping(address => uint256) public onlyOperatorCanClaim;\n\n    /// @notice user -> operator -> authorisation to claim\n    mapping(address => mapping(address => uint256)) public operators;\n\n    uint256[38] private __gap;\n\n    // =================================== EVENTS ==================================\n\n    event Claimed(address indexed user, address indexed token, uint256 amount);\n    event DisputeAmountUpdated(uint256 _disputeAmount);\n    event Disputed(string reason);\n    event DisputePeriodUpdated(uint48 _disputePeriod);\n    event DisputeResolved(bool valid);\n    event DisputeTokenUpdated(address indexed _disputeToken);\n    event OperatorClaimingToggled(address indexed user, bool isEnabled);\n    event OperatorToggled(address indexed user, address indexed operator, bool isWhitelisted);\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n    event Revoked(); // With this event an indexer could maintain a table (timestamp, merkleRootUpdate)\n    event TreeUpdated(bytes32 merkleRoot, bytes32 ipfsHash, uint48 endOfDisputePeriod);\n    event TrustedToggled(address indexed eoa, bool trust);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernorOrGuardian() {\n        if (!core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` is the `user` address or is a trusted address\n    modifier onlyTrustedOrUser(address user) {\n        if (user != msg.sender && canUpdateMerkleRoot[msg.sender] != 1 && !core.isGovernorOrGuardian(msg.sender))\n            revert NotTrusted();\n        _;\n    }\n\n    // ================================ CONSTRUCTOR ================================\n\n    constructor() initializer {}\n\n    function initialize(ICore _core) external initializer {\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGovernorUpgrader(core) {}\n\n    // =============================== MAIN FUNCTION ===============================\n\n    /// @notice Claims rewards for a given set of users\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// who provides the proof and pays the gas: `msg.sender` is used only for addresses that require a trusted operator\n    /// @param users Recipient of tokens\n    /// @param tokens ERC20 claimed\n    /// @param amounts Amount of tokens that will be sent to the corresponding users\n    /// @param proofs Array of hashes bridging from a leaf `(hash of user | token | amount)` to the Merkle root\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external {\n        uint256 usersLength = users.length;\n        if (\n            usersLength == 0 ||\n            usersLength != tokens.length ||\n            usersLength != amounts.length ||\n            usersLength != proofs.length\n        ) revert InvalidLengths();\n\n        for (uint256 i; i < usersLength; ) {\n            address user = users[i];\n            address token = tokens[i];\n            uint256 amount = amounts[i];\n\n            // Only approved operator can claim for `user`\n            if (msg.sender != user && tx.origin != user && operators[user][msg.sender] == 0) revert NotWhitelisted();\n\n            // Verifying proof\n            bytes32 leaf = keccak256(abi.encode(user, token, amount));\n            if (!_verifyProof(leaf, proofs[i])) revert InvalidProof();\n\n            // Closing reentrancy gate here\n            uint256 toSend = amount - claimed[user][token].amount;\n            claimed[user][token] = Claim(SafeCast.toUint208(amount), uint48(block.timestamp), getMerkleRoot());\n\n            IERC20(token).safeTransfer(user, toSend);\n            emit Claimed(user, token, toSend);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Returns the MerkleRoot that is currently live for the contract\n    function getMerkleRoot() public view returns (bytes32) {\n        if (block.timestamp >= endOfDisputePeriod && disputer == address(0)) return tree.merkleRoot;\n        else return lastTree.merkleRoot;\n    }\n\n    // ============================ GOVERNANCE FUNCTIONS ===========================\n\n    /// @notice Adds or removes EOAs which are trusted to update the Merkle root\n    function toggleTrusted(address eoa) external onlyGovernor {\n        uint256 trustedStatus = 1 - canUpdateMerkleRoot[eoa];\n        canUpdateMerkleRoot[eoa] = trustedStatus;\n        emit TrustedToggled(eoa, trustedStatus == 1);\n    }\n\n    /// @notice Updates Merkle Tree\n    function updateTree(MerkleTree calldata _tree) external {\n        if (\n            disputer != address(0) ||\n            // A trusted address cannot update a tree right after a precedent tree update otherwise it can de facto\n            // validate a tree which has not passed the dispute period\n            ((canUpdateMerkleRoot[msg.sender] != 1 || block.timestamp < endOfDisputePeriod) &&\n                !core.isGovernor(msg.sender))\n        ) revert NotTrusted();\n        MerkleTree memory _lastTree = tree;\n        tree = _tree;\n        lastTree = _lastTree;\n\n        uint48 _endOfPeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        endOfDisputePeriod = _endOfPeriod;\n        emit TreeUpdated(_tree.merkleRoot, _tree.ipfsHash, _endOfPeriod);\n    }\n\n    /// @notice Freezes the Merkle tree update until the dispute is resolved\n    /// @dev Requires a deposit of `disputeToken` that'll be slashed if the dispute is not accepted\n    /// @dev It is only possible to create a dispute within `disputePeriod` after each tree update\n    function disputeTree(string memory reason) external {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        if (block.timestamp >= endOfDisputePeriod) revert InvalidDispute();\n        IERC20(disputeToken).safeTransferFrom(msg.sender, address(this), disputeAmount);\n        disputer = msg.sender;\n        emit Disputed(reason);\n    }\n\n    /// @notice Resolve the ongoing dispute, if any\n    /// @param valid Whether the dispute was valid\n    function resolveDispute(bool valid) external onlyGovernor {\n        if (disputer == address(0)) revert NoDispute();\n        if (valid) {\n            IERC20(disputeToken).safeTransfer(disputer, disputeAmount);\n            // If a dispute is valid, the contract falls back to the last tree that was updated\n            _revokeTree();\n        } else {\n            IERC20(disputeToken).safeTransfer(msg.sender, disputeAmount);\n            endOfDisputePeriod = _endOfDisputePeriod(uint48(block.timestamp));\n        }\n        disputer = address(0);\n        emit DisputeResolved(valid);\n    }\n\n    /// @notice Allows the governor of this contract to fallback to the last version of the tree\n    /// immediately\n    function revokeTree() external onlyGovernor {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        _revokeTree();\n    }\n\n    /// @notice Toggles permissioned claiming for a given user\n    /// @dev deprecated\n    function toggleOnlyOperatorCanClaim(address user) external onlyTrustedOrUser(user) {\n        uint256 oldValue = onlyOperatorCanClaim[user];\n        onlyOperatorCanClaim[user] = 1 - oldValue;\n        emit OperatorClaimingToggled(user, oldValue == 0);\n    }\n\n    /// @notice Toggles whitelisting for a given user and a given operator\n    function toggleOperator(address user, address operator) external onlyTrustedOrUser(user) {\n        uint256 oldValue = operators[user][operator];\n        operators[user][operator] = 1 - oldValue;\n        emit OperatorToggled(user, operator, oldValue == 0);\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Sets the dispute period after which a tree update becomes effective\n    function setDisputePeriod(uint48 _disputePeriod) external onlyGovernor {\n        disputePeriod = uint48(_disputePeriod);\n        emit DisputePeriodUpdated(_disputePeriod);\n    }\n\n    /// @notice Sets the token used as a caution during disputes\n    function setDisputeToken(IERC20 _disputeToken) external onlyGovernor {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeToken = _disputeToken;\n        emit DisputeTokenUpdated(address(_disputeToken));\n    }\n\n    /// @notice Sets the amount of `disputeToken` used as a caution during disputes\n    function setDisputeAmount(uint256 _disputeAmount) external onlyGovernor {\n        if (disputer != address(0)) revert UnresolvedDispute();\n        disputeAmount = _disputeAmount;\n        emit DisputeAmountUpdated(_disputeAmount);\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Fallback to the last version of the tree\n    function _revokeTree() internal {\n        MerkleTree memory _tree = lastTree;\n        endOfDisputePeriod = 0;\n        tree = _tree;\n        emit Revoked();\n        emit TreeUpdated(\n            _tree.merkleRoot,\n            _tree.ipfsHash,\n            (uint48(block.timestamp) / _EPOCH_DURATION) * (_EPOCH_DURATION) // Last hour\n        );\n    }\n\n    /// @notice Returns the end of the dispute period\n    /// @dev treeUpdate is rounded up to next hour and then `disputePeriod` hours are added\n    function _endOfDisputePeriod(uint48 treeUpdate) internal view returns (uint48) {\n        return ((treeUpdate - 1) / _EPOCH_DURATION + 1 + disputePeriod) * (_EPOCH_DURATION);\n    }\n\n    /// @notice Checks the validity of a proof\n    /// @param leaf Hashed leaf data, the starting point of the proof\n    /// @param proof Array of hashes forming a hash chain from leaf to root\n    /// @return true If proof is correct, else false\n    function _verifyProof(bytes32 leaf, bytes32[] memory proof) internal view returns (bool) {\n        bytes32 currentHash = leaf;\n        uint256 proofLength = proof.length;\n        for (uint256 i; i < proofLength; ) {\n            if (currentHash < proof[i]) {\n                currentHash = keccak256(abi.encode(currentHash, proof[i]));\n            } else {\n                currentHash = keccak256(abi.encode(proof[i], currentHash));\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        bytes32 root = getMerkleRoot();\n        if (root == bytes32(0)) revert InvalidUninitializedRoot();\n        return currentHash == root;\n    }\n}\n"
    },
    "contracts/external/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControlUpgradeable`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\n//solhint-disable\nabstract contract AccessControlUpgradeable is Initializable {\n    function __AccessControl_init() internal initializer {\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {}\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external {\n        require(account == msg.sender, \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n}\n"
    },
    "contracts/interfaces/CoreModuleInterfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\n/// @title IAngleMiddlemanGauge\n/// @author Angle Core Team\n/// @notice Interface for the `AngleMiddleman` contract\ninterface IAngleMiddlemanGauge {\n    function notifyReward(address gauge, uint256 amount) external;\n}\n\ninterface IStakingRewards {\n    function notifyRewardAmount(uint256 reward) external;\n}\n\ninterface IGaugeController {\n    //solhint-disable-next-line\n    function gauge_types(address addr) external view returns (int128);\n\n    //solhint-disable-next-line\n    function gauge_relative_weight_write(address addr, uint256 timestamp) external returns (uint256);\n\n    //solhint-disable-next-line\n    function gauge_relative_weight(address addr, uint256 timestamp) external view returns (uint256);\n}\n\ninterface ILiquidityGauge {\n    // solhint-disable-next-line\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/external/algebra/IAlgebraPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title IAlgebraPool\n/// @dev Copied from: https://github.com/cryptoalgebra/Algebra/blob/master/src/core/contracts/interfaces/pool/IAlgebraPoolState.sol\ninterface IAlgebraPool {\n    /**\n     * @notice The globalState structure in the pool stores many values but requires only one slot\n     * and is exposed as a single method to save gas when accessed externally.\n     * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\n     * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\n     * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\n     * boundary;\n     * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\n     * Returns timepointIndex The index of the last written timepoint;\n     * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\n     * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\n     * Returns unlocked Whether the pool is currently locked to reentrancy;\n     */\n    function globalState()\n        external\n        view\n        returns (\n            uint160 price,\n            int24 tick,\n            uint16 fee,\n            uint16 timepointIndex,\n            uint8 communityFeeToken0,\n            uint8 communityFeeToken1,\n            bool unlocked\n        );\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3Pool {\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n}\n"
    },
    "contracts/interfaces/IAgToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/// @title IAgToken\n/// @author Angle Core Team\n/// @notice Interface for the stablecoins `AgToken` contracts\n/// @dev This interface only contains functions of the `AgToken` contract which are called by other contracts\n/// of this module or of the first module of the Angle Protocol\ninterface IAgToken is IERC20Upgradeable {\n    // ======================= Minter Role Only Functions ===========================\n\n    /// @notice Lets the `StableMaster` contract or another whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    /// @dev The contracts allowed to issue agTokens are the `StableMaster` contract, `VaultManager` contracts\n    /// associated to this stablecoin as well as the flash loan module (if activated) and potentially contracts\n    /// whitelisted by governance\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(uint256 amount, address burner, address sender) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    // ========================= Treasury Only Functions ===========================\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    // ========================= External functions ================================\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ICore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\n/// @title ICore\n/// @author Angle Labs, Inc.\n/// @notice Interface for the `Core` contracts of smart contract modules used in Angle Labs contracts\ninterface ICore {\n    /// @notice Checks whether an address is governor\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is a governor or a guardian of a module\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport { IAgToken } from \"./IAgToken.sol\";\nimport { ICore } from \"./ICore.sol\";\n\n/// @title ITreasury\n/// @author Angle Core Team\n/// @notice Interface for the `Treasury` contract\n/// @dev This interface only contains functions of the `Treasury` which are called by other contracts\n/// of this module\ninterface ITreasury {\n    /// @notice Stablecoin handled by this `treasury` contract\n    function stablecoin() external view returns (IAgToken);\n\n    /// @notice Checks whether a given address has the  governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether a given address has the guardian or the governor role\n    /// @param admin Address to check\n    /// @return Whether the address has the guardian or the governor role\n    /// @dev Access control is only kept in the `CoreBorrow` contract which means that this function\n    /// queries the `CoreBorrow` contract\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"
    },
    "contracts/middleman/MerklFraxIncentivizationHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../DistributionCreator.sol\";\n\n/// @title MerklFraxIncentivizationHandler\n/// @author Angle Labs, Inc.\n/// @notice Manages the transfer of rewards sent by FRAX `IncentivizingLiquidityAmo` contract to the\n/// `DistributionCreator` contract\n/// @dev This contract is built under the assumption that the `DistributionCreator` contract has already whitelisted\n/// this contract for it to distribute rewards without having to sign a message\ncontract MerklFraxIncentivizationHandler is Ownable {\n    using SafeERC20 for IERC20;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      PARAMETERS                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    address public operatorAddress;\n\n    /// @notice Maps a gauge, incentive token pair to its reward parameters\n    mapping(address => mapping(address => DistributionParameters)) public gaugeParams;\n\n    /// @notice Maps an incentive token to a set of (pool, leftovers)\n    /// @dev Merkl imposes that each token distribution comes with a minimum amount per hour\n    /// We use this mapping to keep track of leftovers to be distributed during future distributions\n    mapping(address => mapping(address => uint256)) public leftovers;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   MODIFIER / EVENT                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    modifier onlyByOwnerOperator() {\n        require(msg.sender == operatorAddress || msg.sender == owner(), \"Not owner or operator\");\n        _;\n    }\n\n    event GaugeSet(address indexed gauge, address indexed incentiveTokenAddress);\n\n    constructor(address _operatorAddress) Ownable() {\n        operatorAddress = _operatorAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                      REFERENCES                                                    \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the Merkl contract managing rewards to be distributed\n    /// @dev Address is the same across the different chains on which it is deployed\n    function merklDistributionCreator() public view virtual returns (DistributionCreator) {\n        return DistributionCreator(0x8BB4C975Ff3c250e0ceEA271728547f3802B36Fd);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                  EXTERNAL FUNCTIONS                                                \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Specifies the reward distribution parameters for `poolAddress`\n    function setGauge(\n        address poolAddress,\n        address incentiveTokenAddress,\n        DistributionParameters memory params\n    ) external onlyByOwnerOperator {\n        if (poolAddress == address(0) || incentiveTokenAddress == address(0)) revert InvalidParams();\n        gaugeParams[poolAddress][incentiveTokenAddress] = params;\n        emit GaugeSet(poolAddress, incentiveTokenAddress);\n    }\n\n    /// @notice Sets the operator of the contract\n    function setOperator(address _operatorAddress) external onlyByOwnerOperator {\n        operatorAddress = _operatorAddress;\n    }\n\n    /// @notice Function called by FRAX contract to stream rewards to `poolAddress`\n    /// @dev Params for the incentivization of the pool must have been set prior to any call for\n    /// a `(poolAddress,incentiveTokenAddress)` pair\n    function incentivizePool(\n        address poolAddress,\n        address,\n        address,\n        address incentiveTokenAddress,\n        uint256,\n        uint256 amount\n    ) external {\n        IERC20(incentiveTokenAddress).safeTransferFrom(msg.sender, address(this), amount);\n        DistributionParameters memory params = gaugeParams[poolAddress][incentiveTokenAddress];\n        if (params.uniV3Pool == address(0)) revert InvalidParams();\n        DistributionCreator creator = merklDistributionCreator();\n        // Minimum amount of incentive tokens to be distributed per hour\n        uint256 minAmount = creator.rewardTokenMinAmounts(incentiveTokenAddress) * params.numEpoch;\n        params.epochStart = uint32(block.timestamp);\n        // Adding the leftover amounts to the total amount to be distributed\n        uint256 leftover = leftovers[incentiveTokenAddress][poolAddress];\n        amount += leftover;\n        params.amount = amount;\n        if (amount > 0) {\n            if (amount > minAmount) {\n                if (leftover > 0) leftovers[incentiveTokenAddress][poolAddress] = 0;\n                _handleIncentiveTokenAllowance(IERC20(incentiveTokenAddress), address(creator), amount);\n                merklDistributionCreator().createDistribution(params);\n            } else {\n                leftovers[incentiveTokenAddress][poolAddress] = amount;\n            }\n        }\n    }\n\n    /// @notice Restores the allowance for the ANGLE token to the `DistributionCreator` contract\n    function _handleIncentiveTokenAllowance(IERC20 incentiveTokenAddress, address spender, uint256 amount) internal {\n        uint256 currentAllowance = incentiveTokenAddress.allowance(address(this), spender);\n        if (currentAllowance < amount) incentiveTokenAddress.safeIncreaseAllowance(spender, amount - currentAllowance);\n    }\n}\n"
    },
    "contracts/middleman/MerklGaugeMiddleman.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../DistributionCreator.sol\";\n\n/// @title MerklGaugeMiddleman\n/// @author Angle Labs, Inc.\n/// @notice Manages the transfer of ANGLE rewards to the `DistributionCreator` contract\n/// @dev This contract is built under the assumption that the `DistributionCreator` contract has already whitelisted\n/// this contract for it to distribute rewards without having to sign a message\n/// @dev Transient funds left in this contract after a call may be exploited\ncontract MerklGaugeMiddleman {\n    using SafeERC20 for IERC20;\n\n    // ================================= PARAMETERS ================================\n\n    /// @notice Contract handling access control\n    ICore public accessControlManager;\n\n    /// @notice Maps a gauge to its reward parameters\n    mapping(address => DistributionParameters) public gaugeParams;\n\n    // =================================== EVENT ===================================\n\n    event GaugeSet(address indexed gauge);\n\n    constructor(ICore _accessControlManager) {\n        if (address(_accessControlManager) == address(0)) revert ZeroAddress();\n        accessControlManager = _accessControlManager;\n        IERC20 _angle = angle();\n        // Condition left here for testing purposes\n        if (address(_angle) != address(0))\n            _angle.safeIncreaseAllowance(address(merklDistributionCreator()), type(uint256).max);\n    }\n\n    // ================================= REFERENCES ================================\n\n    /// @notice Address of the ANGLE token\n    function angle() public view virtual returns (IERC20) {\n        return IERC20(0x31429d1856aD1377A8A0079410B297e1a9e214c2);\n    }\n\n    /// @notice Address of the Merkl contract managing rewards to be distributed\n    /// @dev Address is the same across the different chains on which it is deployed\n    function merklDistributionCreator() public view virtual returns (DistributionCreator) {\n        return DistributionCreator(0x8BB4C975Ff3c250e0ceEA271728547f3802B36Fd);\n    }\n\n    // ============================= EXTERNAL FUNCTIONS ============================\n\n    /// @notice Restores the allowance for the ANGLE token to the `DistributionCreator` contract\n    function setAngleAllowance() external {\n        IERC20 _angle = angle();\n        address manager = address(merklDistributionCreator());\n        uint256 currentAllowance = _angle.allowance(address(this), manager);\n        if (currentAllowance < type(uint256).max)\n            _angle.safeIncreaseAllowance(manager, type(uint256).max - currentAllowance);\n    }\n\n    /// @notice Specifies the reward distribution parameters for `gauge`\n    function setGauge(address gauge, DistributionParameters memory params) external {\n        if (!accessControlManager.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        DistributionCreator manager = merklDistributionCreator();\n        if (\n            gauge == address(0) ||\n            params.rewardToken != address(angle()) ||\n            (manager.isWhitelistedToken(IUniswapV3Pool(params.uniV3Pool).token0()) == 0 &&\n                manager.isWhitelistedToken(IUniswapV3Pool(params.uniV3Pool).token1()) == 0)\n        ) revert InvalidParams();\n        gaugeParams[gauge] = params;\n        emit GaugeSet(gauge);\n    }\n\n    /// @notice Transmits rewards from the `AngleDistributor` to the `DistributionCreator` with the correct\n    /// parameters\n    /// @dev Callable by any contract\n    /// @dev This method can be used to recover leftover ANGLE tokens in the contract\n    function notifyReward(address gauge, uint256 amount) public {\n        DistributionParameters memory params = gaugeParams[gauge];\n        if (params.uniV3Pool == address(0)) revert InvalidParams();\n        if (amount == 0) amount = angle().balanceOf(address(this));\n        params.epochStart = uint32(block.timestamp);\n        params.amount = amount;\n        DistributionCreator creator = merklDistributionCreator();\n        if (amount > 0) {\n            // Need to deal with minimum distribution amounts\n            if (amount > creator.rewardTokenMinAmounts(address(angle())) * params.numEpoch) {\n                merklDistributionCreator().createDistribution(params);\n            } else {\n                // Sending leftover ANGLE tokens to the `msg.sender`\n                angle().safeTransfer(msg.sender, amount);\n            }\n        }\n    }\n\n    /// @notice Fetches tokens and transmits rewards in the same transaction\n    function notifyRewardWithTransfer(address gauge, uint256 amount) external {\n        angle().safeTransferFrom(msg.sender, address(this), amount);\n        notifyReward(gauge, amount);\n    }\n}\n"
    },
    "contracts/middleman/MerklGaugeMiddlemanPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"./MerklGaugeMiddleman.sol\";\n\n/// @title MerklGaugeMiddlemanPolygon\n/// @author Angle Labs, Inc.\ncontract MerklGaugeMiddlemanPolygon is MerklGaugeMiddleman {\n    constructor(ICore _accessControlManager) MerklGaugeMiddleman(_accessControlManager) {}\n\n    function angle() public pure override returns (IERC20) {\n        return IERC20(0x900F717EA076E1E7a484ad9DD2dB81CEEc60eBF1);\n    }\n}\n"
    },
    "contracts/mock/AngleDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./AngleDistributorEvents.sol\";\n\n/// @title AngleDistributor\n/// @author Forked from contracts developed by Curve and Frax and adapted by Angle Core Team\n/// - ERC20CRV.vy (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/ERC20CRV.vy)\n/// - FraxGaugeFXSRewardsDistributor.sol (https://github.com/FraxFinance/frax-solidity/blob/master/src/hardhat/contracts/Curve/FraxGaugeFXSRewardsDistributor.sol)\n/// @notice All the events used in `AngleDistributor` contract\ncontract AngleDistributor is AngleDistributorEvents, ReentrancyGuardUpgradeable, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for the guardian\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    /// @notice Length of a week in seconds\n    uint256 public constant WEEK = 3600 * 24 * 7;\n\n    /// @notice Time at which the emission rate is updated\n    uint256 public constant RATE_REDUCTION_TIME = WEEK;\n\n    /// @notice Reduction of the emission rate\n    uint256 public constant RATE_REDUCTION_COEFFICIENT = 1007827884862117171; // 1.5 ^ (1/52) * 10**18\n\n    /// @notice Base used for computation\n    uint256 public constant BASE = 10**18;\n\n    /// @notice Maps the address of a gauge to the last time this gauge received rewards\n    mapping(address => uint256) public lastTimeGaugePaid;\n\n    /// @notice Maps the address of a gauge to whether it was killed or not\n    /// A gauge killed in this contract cannot receive any rewards\n    mapping(address => bool) public killedGauges;\n\n    /// @notice Maps the address of a type >= 2 gauge to a delegate address responsible\n    /// for giving rewards to the actual gauge\n    mapping(address => address) public delegateGauges;\n\n    /// @notice Maps the address of a gauge delegate to whether this delegate supports the `notifyReward` interface\n    /// and is therefore built for automation\n    mapping(address => bool) public isInterfaceKnown;\n\n    /// @notice Address of the ANGLE token given as a reward\n    IERC20 public rewardToken;\n\n    /// @notice Address of the `GaugeController` contract\n    IGaugeController public controller;\n\n    /// @notice Address responsible for pulling rewards of type >= 2 gauges and distributing it to the\n    /// associated contracts if there is not already an address delegated for this specific contract\n    address public delegateGauge;\n\n    /// @notice ANGLE current emission rate, it is first defined in the initializer and then updated every week\n    uint256 public rate;\n\n    /// @notice Timestamp at which the current emission epoch started\n    uint256 public startEpochTime;\n\n    /// @notice Amount of ANGLE tokens distributed through staking at the start of the epoch\n    /// This is an informational variable used to track how much has been distributed through liquidity mining\n    uint256 public startEpochSupply;\n\n    /// @notice Index of the current emission epoch\n    /// Here also, this variable is not useful per se inside the smart contracts of the protocol, it is\n    /// just an informational variable\n    uint256 public miningEpoch;\n\n    /// @notice Whether ANGLE distribution through this contract is on or no\n    bool public distributionsOn;\n\n    /// @notice Constructor of the contract\n    /// @param _rewardToken Address of the ANGLE token\n    /// @param _controller Address of the GaugeController\n    /// @param _initialRate Initial ANGLE emission rate\n    /// @param _startEpochSupply Amount of ANGLE tokens already distributed via liquidity mining\n    /// @param governor Governor address of the contract\n    /// @param guardian Address of the guardian of this contract\n    /// @param _delegateGauge Address that will be used to pull rewards for type 2 gauges\n    /// @dev After this contract is created, the correct amount of ANGLE tokens should be transferred to the contract\n    /// @dev The `_delegateGauge` can be the zero address\n    function initialize(\n        address _rewardToken,\n        address _controller,\n        uint256 _initialRate,\n        uint256 _startEpochSupply,\n        address governor,\n        address guardian,\n        address _delegateGauge\n    ) external initializer {\n        require(\n            _controller != address(0) && _rewardToken != address(0) && guardian != address(0) && governor != address(0),\n            \"0\"\n        );\n        rewardToken = IERC20(_rewardToken);\n        controller = IGaugeController(_controller);\n        startEpochSupply = _startEpochSupply;\n        miningEpoch = 0;\n        // Some ANGLE tokens should be sent to the contract directly after initialization\n        rate = _initialRate;\n        delegateGauge = _delegateGauge;\n        distributionsOn = false;\n        startEpochTime = block.timestamp;\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setupRole(GUARDIAN_ROLE, governor);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ======================== Internal Functions =================================\n\n    /// @notice Internal function to distribute rewards to a gauge\n    /// @param gaugeAddr Address of the gauge to distribute rewards to\n    /// @return weeksElapsed Weeks elapsed since the last call\n    /// @return rewardTally Amount of rewards distributed to the gauge\n    /// @dev The reason for having an internal function is that it's called by the `distributeReward` and the\n    /// `distributeRewardToMultipleGauges`\n    /// @dev Although they would need to be performed all the time this function is called, this function does not\n    /// contain checks on whether distribution is on, and on whether rate should be reduced. These are done in each external\n    /// function calling this function for gas efficiency\n    function _distributeReward(address gaugeAddr) internal returns (uint256 weeksElapsed, uint256 rewardTally) {\n        // Checking if the gauge has been added or if it still possible to distribute rewards to this gauge\n        int128 gaugeType = IGaugeController(controller).gauge_types(gaugeAddr);\n        require(gaugeType >= 0 && !killedGauges[gaugeAddr], \"110\");\n\n        // Calculate the elapsed time in weeks.\n        uint256 lastTimePaid = lastTimeGaugePaid[gaugeAddr];\n\n        // Edge case for first reward for this gauge\n        if (lastTimePaid == 0) {\n            weeksElapsed = 1;\n            if (gaugeType == 0) {\n                // We give a full approval for the gauges with type zero which correspond to the staking\n                // contracts of the protocol\n                rewardToken.safeApprove(gaugeAddr, type(uint256).max);\n            }\n        } else {\n            // Truncation desired\n            weeksElapsed = (block.timestamp - lastTimePaid) / WEEK;\n            // Return early here for 0 weeks instead of throwing, as it could have bad effects in other contracts\n            if (weeksElapsed == 0) {\n                return (0, 0);\n            }\n        }\n        rewardTally = 0;\n        // We use this variable to keep track of the emission rate across different weeks\n        uint256 weeklyRate = rate;\n        for (uint256 i = 0; i < weeksElapsed; i++) {\n            uint256 relWeightAtWeek;\n            if (i == 0) {\n                // Mutative, for the current week: makes sure the weight is checkpointed. Also returns the weight.\n                relWeightAtWeek = controller.gauge_relative_weight_write(gaugeAddr, block.timestamp);\n            } else {\n                // View\n                relWeightAtWeek = controller.gauge_relative_weight(gaugeAddr, (block.timestamp - WEEK * i));\n            }\n            rewardTally += (weeklyRate * relWeightAtWeek * WEEK) / BASE;\n\n            // To get the rate of the week prior from the current rate we just have to multiply by the weekly division\n            // factor\n            // There may be some precisions error: inferred previous values of the rate may be different to what we would\n            // have had if the rate had been computed correctly in these weeks: we expect from empirical observations\n            // this `weeklyRate` to be inferior to what the `rate` would have been\n            weeklyRate = (weeklyRate * RATE_REDUCTION_COEFFICIENT) / BASE;\n        }\n\n        // Update the last time paid, rounded to the closest week\n        // in order not to have an ever moving time on when to call this function\n        lastTimeGaugePaid[gaugeAddr] = (block.timestamp / WEEK) * WEEK;\n\n        // If the `gaugeType >= 2`, this means that the gauge is a gauge on another chain (and corresponds to tokens\n        // that need to be bridged) or is associated to an external contract of the Angle Protocol\n        if (gaugeType >= 2) {\n            // If it is defined, we use the specific delegate attached to the gauge\n            address delegate = delegateGauges[gaugeAddr];\n            if (delegate == address(0)) {\n                // If not, we check if a delegate common to all gauges with type >= 2 can be used\n                delegate = delegateGauge;\n            }\n            if (delegate != address(0)) {\n                _sendDelegateRewards(gaugeAddr, delegate, rewardTally);\n            } else {\n                rewardToken.safeTransfer(gaugeAddr, rewardTally);\n            }\n        } else if (gaugeType == 1) {\n            // This is for the case of Perpetual contracts which need to be able to receive their reward tokens\n            rewardToken.safeTransfer(gaugeAddr, rewardTally);\n            IStakingRewards(gaugeAddr).notifyRewardAmount(rewardTally);\n        } else {\n            // Potentially override the gauge address\n            address delegate = delegateGauges[gaugeAddr];\n            if (delegate != address(0)) {\n                _sendDelegateRewards(gaugeAddr, delegate, rewardTally);\n            } else {\n                ILiquidityGauge(gaugeAddr).deposit_reward_token(address(rewardToken), rewardTally);\n            }\n        }\n        emit RewardDistributed(gaugeAddr, rewardTally);\n    }\n\n    /// @notice Helper to send `rewardTally` for `gaugeAddr` to the non zero `delegate` address\n    function _sendDelegateRewards(\n        address gaugeAddr,\n        address delegate,\n        uint256 rewardTally\n    ) internal {\n        rewardToken.safeTransfer(delegate, rewardTally);\n        // If this delegate supports a specific interface, then rewards sent are notified through this\n        // interface\n        if (isInterfaceKnown[delegate]) {\n            IAngleMiddlemanGauge(delegate).notifyReward(gaugeAddr, rewardTally);\n        }\n    }\n\n    /// @notice Updates mining rate and supply at the start of the epoch\n    /// @dev Any modifying mining call must also call this\n    /// @dev It is possible that more than one week past between two calls of this function, and for this reason\n    /// this function has been slightly modified from Curve implementation by Angle Team\n    function _updateMiningParameters() internal {\n        // When entering this function, we always have: `(block.timestamp - startEpochTime) / RATE_REDUCTION_TIME >= 1`\n        uint256 epochDelta = (block.timestamp - startEpochTime) / RATE_REDUCTION_TIME;\n\n        // Storing intermediate values for the rate and for the `startEpochSupply`\n        uint256 _rate = rate;\n        uint256 _startEpochSupply = startEpochSupply;\n\n        startEpochTime += RATE_REDUCTION_TIME * epochDelta;\n        miningEpoch += epochDelta;\n\n        for (uint256 i = 0; i < epochDelta; i++) {\n            // Updating the intermediate values of the `startEpochSupply`\n            _startEpochSupply += _rate * RATE_REDUCTION_TIME;\n            _rate = (_rate * BASE) / RATE_REDUCTION_COEFFICIENT;\n        }\n        rate = _rate;\n        startEpochSupply = _startEpochSupply;\n        emit UpdateMiningParameters(block.timestamp, _rate, _startEpochSupply);\n    }\n\n    /// @notice Toggles the fact that a gauge delegate can be used for automation or not and therefore supports\n    /// the `notifyReward` interface\n    /// @param _delegateGauge Address of the gauge to change\n    function _toggleInterfaceKnown(address _delegateGauge) internal {\n        bool isInterfaceKnownMem = isInterfaceKnown[_delegateGauge];\n        isInterfaceKnown[_delegateGauge] = !isInterfaceKnownMem;\n        emit InterfaceKnownToggled(_delegateGauge, !isInterfaceKnownMem);\n    }\n\n    // ================= Permissionless External Functions =========================\n\n    /// @notice Distributes rewards to a staking contract (also called gauge)\n    /// @param gaugeAddr Address of the gauge to send tokens too\n    /// @return weeksElapsed Number of weeks elapsed since the last time rewards were distributed\n    /// @return rewardTally Amount of tokens sent to the gauge\n    /// @dev Anyone can call this function to distribute rewards to the different staking contracts\n    function distributeReward(address gaugeAddr) external nonReentrant returns (uint256, uint256) {\n        // Checking if distribution is on\n        require(distributionsOn == true, \"109\");\n        // Updating rate distribution parameters if need be\n        if (block.timestamp >= startEpochTime + RATE_REDUCTION_TIME) {\n            _updateMiningParameters();\n        }\n        return _distributeReward(gaugeAddr);\n    }\n\n    /// @notice Distributes rewards to multiple staking contracts\n    /// @param gauges Addresses of the gauge to send tokens too\n    /// @dev Anyone can call this function to distribute rewards to the different staking contracts\n    /// @dev Compared with the `distributeReward` function, this function sends rewards to multiple\n    /// contracts at the same time\n    function distributeRewardToMultipleGauges(address[] memory gauges) external nonReentrant {\n        // Checking if distribution is on\n        require(distributionsOn == true, \"109\");\n        // Updating rate distribution parameters if need be\n        if (block.timestamp >= startEpochTime + RATE_REDUCTION_TIME) {\n            _updateMiningParameters();\n        }\n        for (uint256 i = 0; i < gauges.length; i++) {\n            _distributeReward(gauges[i]);\n        }\n    }\n\n    /// @notice Updates mining rate and supply at the start of the epoch\n    /// @dev Callable by any address, but only once per epoch\n    function updateMiningParameters() external {\n        require(block.timestamp >= startEpochTime + RATE_REDUCTION_TIME, \"108\");\n        _updateMiningParameters();\n    }\n\n    // ========================= Governor Functions ================================\n\n    /// @notice Withdraws ERC20 tokens that could accrue on this contract\n    /// @param tokenAddress Address of the ERC20 token to withdraw\n    /// @param to Address to transfer to\n    /// @param amount Amount to transfer\n    /// @dev Added to support recovering LP Rewards and other mistaken tokens\n    /// from other systems to be distributed to holders\n    /// @dev This function could also be used to recover ANGLE tokens in case the rate got smaller\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external onlyRole(GOVERNOR_ROLE) {\n        // If the token is the ANGLE token, we need to make sure that governance is not going to withdraw\n        // too many tokens and that it'll be able to sustain the weekly distribution forever\n        // This check assumes that `distributeReward` has been called for gauges and that there are no gauges\n        // which have not received their past week's rewards\n        if (tokenAddress == address(rewardToken)) {\n            uint256 currentBalance = rewardToken.balanceOf(address(this));\n            // The amount distributed till the end is `rate * WEEK / (1 - RATE_REDUCTION_FACTOR)` where\n            // `RATE_REDUCTION_FACTOR = BASE / RATE_REDUCTION_COEFFICIENT` which translates to:\n            require(\n                currentBalance >=\n                    ((rate * RATE_REDUCTION_COEFFICIENT) * WEEK) / (RATE_REDUCTION_COEFFICIENT - BASE) + amount,\n                \"4\"\n            );\n        }\n        IERC20(tokenAddress).safeTransfer(to, amount);\n        emit Recovered(tokenAddress, to, amount);\n    }\n\n    /// @notice Sets a new gauge controller\n    /// @param _controller Address of the new gauge controller\n    function setGaugeController(address _controller) external onlyRole(GOVERNOR_ROLE) {\n        require(_controller != address(0), \"0\");\n        controller = IGaugeController(_controller);\n        emit GaugeControllerUpdated(_controller);\n    }\n\n    /// @notice Sets a new delegate gauge for pulling rewards of a type >= 2 gauges or of all type >= 2 gauges\n    /// @param gaugeAddr Gauge to change the delegate of\n    /// @param _delegateGauge Address of the new gauge delegate related to `gaugeAddr`\n    /// @param toggleInterface Whether we should toggle the fact that the `_delegateGauge` is built for automation or not\n    /// @dev This function can be used to remove delegating or introduce the pulling of rewards to a given address\n    /// @dev If `gaugeAddr` is the zero address, this function updates the delegate gauge common to all gauges with type >= 2\n    /// @dev The `toggleInterface` parameter has been added for convenience to save one transaction when adding a gauge delegate\n    /// which supports the `notifyReward` interface\n    function setDelegateGauge(\n        address gaugeAddr,\n        address _delegateGauge,\n        bool toggleInterface\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (gaugeAddr != address(0)) {\n            delegateGauges[gaugeAddr] = _delegateGauge;\n        } else {\n            delegateGauge = _delegateGauge;\n        }\n        emit DelegateGaugeUpdated(gaugeAddr, _delegateGauge);\n\n        if (toggleInterface) {\n            _toggleInterfaceKnown(_delegateGauge);\n        }\n    }\n\n    /// @notice Changes the ANGLE emission rate\n    /// @param _newRate New ANGLE emission rate\n    /// @dev It is important to be super wary when calling this function and to make sure that `distributeReward`\n    /// has been called for all gauges in the past weeks. If not, gauges may get an incorrect distribution of ANGLE rewards\n    /// for these past weeks based on the new rate and not on the old rate\n    /// @dev Governance should thus make sure to call this function rarely and when it does to do it after the weekly `distributeReward`\n    /// calls for all existing gauges\n    /// @dev As this function assumes that `distributeReward` has been called during the week, it also assumes that the `startEpochSupply`\n    /// parameter has been put up to date\n    function setRate(uint256 _newRate) external onlyRole(GOVERNOR_ROLE) {\n        // Checking if the new rate is compatible with the amount of ANGLE tokens this contract has in balance\n        // This check assumes, like this function, that `distributeReward` has correctly been called before\n        require(\n            rewardToken.balanceOf(address(this)) >=\n                ((_newRate * RATE_REDUCTION_COEFFICIENT) * WEEK) / (RATE_REDUCTION_COEFFICIENT - BASE),\n            \"4\"\n        );\n        rate = _newRate;\n        emit RateUpdated(_newRate);\n    }\n\n    /// @notice Toggles the status of a gauge to either killed or unkilled\n    /// @param gaugeAddr Gauge to toggle the status of\n    /// @dev It is impossible to kill a gauge in the `GaugeController` contract, for this reason killing of gauges\n    /// takes place in the `AngleDistributor` contract\n    /// @dev This means that people could vote for a gauge in the gauge controller contract but that rewards are not going\n    /// to be distributed to it in the end: people would need to remove their weights on the gauge killed to end the diminution\n    /// in rewards\n    /// @dev In the case of a gauge being killed, this function resets the timestamps at which this gauge has been approved and\n    /// disapproves the gauge to spend the token\n    /// @dev It should be cautiously called by governance as it could result in less ANGLE overall rewards than initially planned\n    /// if people do not remove their voting weights to the killed gauge\n    function toggleGauge(address gaugeAddr) external onlyRole(GOVERNOR_ROLE) {\n        bool gaugeKilledMem = killedGauges[gaugeAddr];\n        if (!gaugeKilledMem) {\n            delete lastTimeGaugePaid[gaugeAddr];\n            rewardToken.safeApprove(gaugeAddr, 0);\n        }\n        killedGauges[gaugeAddr] = !gaugeKilledMem;\n        emit GaugeToggled(gaugeAddr, !gaugeKilledMem);\n    }\n\n    // ========================= Guardian Function =================================\n\n    /// @notice Halts or activates distribution of rewards\n    function toggleDistributions() external onlyRole(GUARDIAN_ROLE) {\n        bool distributionsOnMem = distributionsOn;\n        distributionsOn = !distributionsOnMem;\n        emit DistributionsToggled(!distributionsOnMem);\n    }\n\n    /// @notice Notifies that the interface of a gauge delegate is known or has changed\n    /// @param _delegateGauge Address of the gauge to change\n    /// @dev Gauge delegates that are built for automation should be toggled\n    function toggleInterfaceKnown(address _delegateGauge) external onlyRole(GUARDIAN_ROLE) {\n        _toggleInterfaceKnown(_delegateGauge);\n    }\n}\n"
    },
    "contracts/mock/AngleDistributorEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../interfaces/CoreModuleInterfaces.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\n/// @title AngleDistributorEvents\n/// @author Angle Core Team\n/// @notice All the events used in `AngleDistributor` contract\ncontract AngleDistributorEvents {\n    event DelegateGaugeUpdated(address indexed _gaugeAddr, address indexed _delegateGauge);\n    event DistributionsToggled(bool _distributionsOn);\n    event GaugeControllerUpdated(address indexed _controller);\n    event GaugeToggled(address indexed gaugeAddr, bool newStatus);\n    event InterfaceKnownToggled(address indexed _delegateGauge, bool _isInterfaceKnown);\n    event RateUpdated(uint256 _newRate);\n    event Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\n    event RewardDistributed(address indexed gaugeAddr, uint256 rewardTally);\n    event UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n}\n"
    },
    "contracts/mock/MockCoreBorrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\ncontract MockCoreBorrow {\n    mapping(address => bool) public governors;\n    mapping(address => bool) public guardians;\n\n    function isGovernor(address admin) external view returns (bool) {\n        return governors[admin];\n    }\n\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return governors[admin] || guardians[admin];\n    }\n\n    function toggleGovernor(address admin) external {\n        governors[admin] = !governors[admin];\n    }\n\n    function toggleGuardian(address admin) external {\n        guardians[admin] = !guardians[admin];\n    }\n}\n"
    },
    "contracts/mock/MockMerklFraxIncentivizationHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"../middleman/MerklFraxIncentivizationHandler.sol\";\n\ncontract MockMerklFraxIncentivizationHandler is MerklFraxIncentivizationHandler {\n    DistributionCreator public manager;\n\n    constructor(address _operator) MerklFraxIncentivizationHandler(_operator) {}\n\n    function merklDistributionCreator() public view override returns (DistributionCreator) {\n        return manager;\n    }\n\n    function setAddresses(DistributionCreator _manager) external {\n        manager = _manager;\n    }\n}\n"
    },
    "contracts/mock/MockMerklGaugeMiddleman.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport \"../middleman/MerklGaugeMiddleman.sol\";\n\ncontract MockMerklGaugeMiddleman is MerklGaugeMiddleman {\n    address public angleDistributorAddress;\n    IERC20 public angleAddress;\n    DistributionCreator public manager;\n\n    constructor(ICore _coreBorrow) MerklGaugeMiddleman(_coreBorrow) {}\n\n    function angle() public view override returns (IERC20) {\n        return angleAddress;\n    }\n\n    function merklDistributionCreator() public view override returns (DistributionCreator) {\n        return manager;\n    }\n\n    function setAddresses(\n        address _angleDistributorAddress,\n        IERC20 _angleAddress,\n        DistributionCreator _manager\n    ) external {\n        angleDistributorAddress = _angleDistributorAddress;\n        angleAddress = _angleAddress;\n        manager = _manager;\n    }\n}\n"
    },
    "contracts/mock/MockPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ncontract MockPool {\n    address public token0;\n    address public token1;\n    uint32 public constant EPOCH_DURATION = 3600;\n\n    function setToken(address token, uint256 who) external {\n        if (who == 0) token0 = token;\n        else token1 = token;\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n}\n"
    },
    "contracts/mock/MockTokenPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockTokenPermit is ERC20Permit {\n    using SafeERC20 for IERC20;\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n    mapping(address => bool) public minters;\n    address public treasury;\n    uint256 public fees;\n\n    bool public reverts;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20Permit(name_) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n\n    function burnSelf(uint256 amount, address account) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function addMinter(address minter) public {\n        minters[minter] = true;\n    }\n\n    function removeMinter(address minter) public {\n        minters[minter] = false;\n    }\n\n    function setTreasury(address _treasury) public {\n        treasury = _treasury;\n    }\n\n    function setFees(uint256 _fees) public {\n        fees = _fees;\n    }\n\n    function recoverERC20(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external {\n        token.safeTransfer(to, amount);\n    }\n\n    function swapIn(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(!reverts);\n\n        IERC20(bridgeToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 canonicalOut = amount;\n        canonicalOut -= (canonicalOut * fees) / 10**9;\n        _mint(to, canonicalOut);\n        return canonicalOut;\n    }\n\n    function swapOut(\n        address bridgeToken,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        require(!reverts);\n        _burn(msg.sender, amount);\n        uint256 bridgeOut = amount;\n        bridgeOut -= (bridgeOut * fees) / 10**9;\n        IERC20(bridgeToken).safeTransfer(to, bridgeOut);\n        return bridgeOut;\n    }\n}\n"
    },
    "contracts/mock/MockTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\ncontract MockTreasury {\n    address public stablecoin;\n    address public governor;\n    address public guardian;\n    address public vaultManager1;\n    address public vaultManager2;\n    address public flashLoanModule;\n\n    constructor(\n        address _stablecoin,\n        address _governor,\n        address _guardian,\n        address _vaultManager1,\n        address _vaultManager2,\n        address _flashLoanModule\n    ) {\n        stablecoin = _stablecoin;\n        governor = _governor;\n        guardian = _guardian;\n        vaultManager1 = _vaultManager1;\n        vaultManager2 = _vaultManager2;\n        flashLoanModule = _flashLoanModule;\n    }\n\n    function isGovernor(address admin) external view returns (bool) {\n        return (admin == governor);\n    }\n\n    function isGovernorOrGuardian(address admin) external view returns (bool) {\n        return (admin == governor || admin == guardian);\n    }\n}\n"
    },
    "contracts/mock/MockUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\ncontract MockUniswapV3Pool {\n    address public token0;\n    address public token1;\n    uint32 public constant EPOCH_DURATION = 3600;\n    uint256 public fee;\n\n    function setToken(address token, uint256 who) external {\n        if (who == 0) token0 = token;\n        else token1 = token;\n    }\n\n    function round(uint256 amount) external pure returns (uint256) {\n        return (amount / EPOCH_DURATION) * EPOCH_DURATION;\n    }\n}\n"
    },
    "contracts/struct/CampaignParameters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nstruct CampaignParameters {\n    // POPULATED ONCE CREATED\n\n    // ID of the campaign. This can be left as a null bytes32 when creating campaigns\n    // on Merkl.\n    bytes32 campaignId;\n    // CHOSEN BY CAMPAIGN CREATOR\n\n    // Address of the campaign creator, if marked as address(0), it will be overriden with the\n    // address of the `msg.sender` creating the campaign\n    address creator;\n    // Address of the token used as a reward\n    address rewardToken;\n    // Amount of `rewardToken` to distribute across all the epochs\n    // Amount distributed per epoch is `amount/numEpoch`\n    uint256 amount;\n    // Type of campaign\n    uint32 campaignType;\n    // Timestamp at which the campaign should start\n    uint32 startTimestamp;\n    // Duration of the campaign in seconds. Has to be a multiple of EPOCH = 3600\n    uint32 duration;\n    // Extra data to pass to specify the campaign\n    bytes campaignData;\n}\n"
    },
    "contracts/struct/DistributionParameters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nstruct DistributionParameters {\n    // ID of the reward (populated once created). This can be left as a null bytes32 when creating distributions\n    // on Merkl.\n    bytes32 rewardId;\n    // Address of the UniswapV3 pool that needs to be incentivized\n    address uniV3Pool;\n    // Address of the reward token for the incentives\n    address rewardToken;\n    // Amount of `rewardToken` to distribute across all the epochs\n    // Amount distributed per epoch is `amount/numEpoch`\n    uint256 amount;\n    // List of all position wrappers to consider or not for this contract. Some wrappers like Gamma or Arrakis\n    // are automatically detected and so there is no need to specify them here. Check out the docs to find out\n    // which need to be specified and which are not automatically detected.\n    address[] positionWrappers;\n    // Type (blacklist==3, whitelist==0, ...) encoded as a `uint32` for each wrapper in the list above. Mapping between\n    // wrapper types and their corresponding `uint32` value can be found in Angle Docs\n    uint32[] wrapperTypes;\n    // In the incentivization formula, how much of the fees should go to holders of token0\n    // in base 10**4\n    uint32 propToken0;\n    // Proportion for holding token1 (in base 10**4)\n    uint32 propToken1;\n    // Proportion for providing a useful liquidity (in base 10**4) that generates fees\n    uint32 propFees;\n    // Timestamp at which the incentivization should start. This is in the same units as `block.timestamp`.\n    uint32 epochStart;\n    // Amount of epochs for which incentivization should last. Epochs are expressed in hours here, so for a\n    // campaign of 1 week `numEpoch` should for instance be 168.\n    uint32 numEpoch;\n    // Whether out of range liquidity should still be incentivized or not\n    // This should be equal to 1 if out of range liquidity should still be incentivized\n    // and 0 otherwise.\n    uint32 isOutOfRangeIncentivized;\n    // How much more addresses with a maximum boost can get with respect to addresses\n    // which do not have a boost (in base 4). In the case of Curve where addresses get 2.5x more\n    // this would be 25000.\n    uint32 boostedReward;\n    // Address of the token which dictates who gets boosted rewards or not. This is optional\n    // and if the zero address is given no boost will be taken into account. In the case of Curve, this address\n    // would for instance be the veBoostProxy address, or in other cases the veToken address.\n    address boostingAddress;\n    // Additional data passed when distributing rewards. This parameter may be used in case\n    // the reward distribution script needs to look into other parameters beyond the ones above.\n    // In most cases, when creating a campaign on Merkl, you can leave this as an empty bytes.\n    bytes additionalData;\n}\n"
    },
    "contracts/struct/ExtensiveDistributionParameters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport { DistributionParameters } from \"./DistributionParameters.sol\";\n\nstruct UniswapTokenData {\n    address add;\n    uint8 decimals;\n    string symbol;\n    uint256 poolBalance;\n}\n\nstruct ExtensiveDistributionParameters {\n    DistributionParameters base;\n    // Uniswap pool data\n    uint24 poolFee;\n    UniswapTokenData token0;\n    UniswapTokenData token1;\n    // rewardToken data\n    string rewardTokenSymbol;\n    uint8 rewardTokenDecimals;\n}\n"
    },
    "contracts/struct/RewardTokenAmounts.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nstruct RewardTokenAmounts {\n    address token;\n    uint256 minimumAmountPerEpoch;\n}\n"
    },
    "contracts/TokenLocker.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable2Step, Ownable } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ncontract TokenLocker is Ownable2Step {\n    IERC20 public asset;\n\n    uint256 public lockPeriod;\n    uint256 public participantNumber;\n    uint256 public totalSupply;\n    uint256 public constant MAX_LOCK_PERIOD = 60 * 60 * 24 * 180;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) public lockedDeposit;\n    mapping(address => uint256) public unlockTime;\n\n    event LockPeriodUpdated(uint256 lockPeriod);\n    event Deposit(address depositor, uint256 amount);\n    event Withdraw(address caller, address receiver, uint256 amount);\n\n    error InvalidDepositAmount();\n    error InsufficientLockPeriod();\n    error InsufficientDeposit();\n    error ZeroAddressReceipient();\n    error InvalidLockPeriod();\n\n    modifier onlyValidLockPeriod(uint256 _lockPeriod) {\n        if (_lockPeriod > MAX_LOCK_PERIOD) {\n            revert InvalidLockPeriod();\n        }\n        _;\n    }\n\n    constructor(\n        address _owner,\n        IERC20 _asset,\n        uint256 _lockPeriod,\n        string memory _name,\n        string memory _symbol\n    ) onlyValidLockPeriod(_lockPeriod) {\n        asset = _asset;\n        lockPeriod = _lockPeriod;\n        name = _name;\n        symbol = _symbol;\n        _transferOwnership(_owner);\n    }\n\n    function updateLockPeriod(uint256 _lockPeriod) external onlyOwner onlyValidLockPeriod(_lockPeriod) {\n        lockPeriod = _lockPeriod;\n\n        emit LockPeriodUpdated(_lockPeriod);\n    }\n\n    function deposit(uint256 _amount) external {\n        if (_amount == 0) {\n            revert InvalidDepositAmount();\n        }\n        if (lockedDeposit[msg.sender] == 0) {\n            unchecked {\n                ++participantNumber;\n            }\n        }\n\n        SafeERC20.safeTransferFrom(asset, msg.sender, address(this), _amount);\n\n        lockedDeposit[msg.sender] += _amount;\n        unlockTime[msg.sender] = block.timestamp;\n        totalSupply += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _amount, address _receiver) external {\n        if (_receiver == address(0)) {\n            revert ZeroAddressReceipient();\n        }\n        uint256 userLockedDeposit = lockedDeposit[msg.sender];\n        if (userLockedDeposit < _amount) {\n            revert InsufficientDeposit();\n        }\n        if (block.timestamp < getUnlockableTimestamp(msg.sender)) {\n            revert InsufficientLockPeriod();\n        }\n        if ((userLockedDeposit - _amount) == 0) {\n            delete unlockTime[msg.sender];\n            --participantNumber;\n        }\n\n        lockedDeposit[msg.sender] -= _amount;\n        totalSupply -= _amount;\n\n        SafeERC20.safeTransfer(asset, _receiver, _amount);\n\n        emit Withdraw(msg.sender, _receiver, _amount);\n    }\n\n    function getUnlockableTimestamp(address _locker) public view returns (uint256) {\n        uint256 unlock = unlockTime[_locker];\n        return (unlock == 0) ? 0 : unlock + lockPeriod;\n    }\n\n    function decimals() external view returns (uint256) {\n        return IERC20Metadata(address(asset)).decimals();\n    }\n\n    function balanceOf(address _locker) external view returns (uint256) {\n        return lockedDeposit[_locker];\n    }\n}\n"
    },
    "contracts/tokenWrappers/AaveTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../DistributionCreator.sol\";\n\nimport \"../utils/UUPSHelper.sol\";\n\ncontract AaveTokenWrapper is UUPSHelper, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    // ================================= VARIABLES =================================\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    // could be put as immutable in non upgradeable contract\n    address public token;\n    address public distributor;\n    address public distributionCreator;\n\n    mapping(address => uint256) public isMasterClaimer;\n    mapping(address => address) public delegateReceiver;\n    mapping(address => uint256) public permissionlessClaim;\n\n    error InvalidClaim();\n\n    // =================================== EVENTS ==================================\n\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    // ================================= FUNCTIONS =================================\n\n    function initialize(\n        address underlyingToken,\n        address _distributor,\n        address _core,\n        address _distributionCreator\n    ) public initializer {\n        // TODO could fetch name and symbol based on real token\n        __ERC20_init(\"AaveTokenWrapper\", \"ATW\");\n        __UUPSUpgradeable_init();\n        if (underlyingToken == address(0) || _distributor == address(0) || _distributionCreator == address(0))\n            revert ZeroAddress();\n        ICore(_core).isGovernor(msg.sender);\n        token = underlyingToken;\n        distributor = _distributor;\n        distributionCreator = _distributionCreator;\n        core = ICore(_core);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        // Needs an approval before hand, this is how mints are done\n        if (to == distributor) {\n            IERC20(token).safeTransferFrom(from, address(this), amount);\n            _mint(from, amount); // These are then transfered to the distributor\n        } else {\n            if (to == _getFeeRecipient()) {\n                IERC20(token).safeTransferFrom(from, to, amount);\n                _mint(from, amount);\n            }\n        }\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (from == address(distributor)) {\n            if (tx.origin == to || permissionlessClaim[to] == 1 || isMasterClaimer[tx.origin] == 1) {\n                _handleClaim(to, amount);\n            } else if (allowance(to, tx.origin) > amount) {\n                _spendAllowance(to, tx.origin, amount);\n                _handleClaim(to, amount);\n            } else {\n                revert InvalidClaim();\n            }\n        } else if (to == _getFeeRecipient()) {\n            // To avoid having any token aside from the distributor\n            _burn(to, amount);\n        }\n    }\n\n    function _handleClaim(address to, uint256 amount) internal {\n        address delegate = delegateReceiver[to];\n        _burn(to, amount);\n        if (delegate == address(0) || delegate == to) {\n            IERC20(token).safeTransfer(to, amount);\n        } else {\n            IERC20(token).safeTransfer(delegate, amount);\n        }\n    }\n\n    function _getFeeRecipient() internal view returns (address feeRecipient) {\n        address _distributionCreator = distributionCreator;\n        feeRecipient = DistributionCreator(_distributionCreator).feeRecipient();\n        feeRecipient = feeRecipient == address(0) ? _distributionCreator : feeRecipient;\n    }\n\n    /// @notice Recovers any ERC20 token\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    function toggleMasterClaimer(address claimer) external onlyGovernor {\n        uint256 claimStatus = 1 - isMasterClaimer[claimer];\n        isMasterClaimer[claimer] = claimStatus;\n    }\n\n    function togglePermissionlessClaim() external {\n        uint256 permission = 1 - permissionlessClaim[msg.sender];\n        permissionlessClaim[msg.sender] = permission;\n    }\n\n    function updateDelegateReceiver(address receiver) external {\n        delegateReceiver[msg.sender] = receiver;\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGovernorUpgrader(core) {}\n}\n"
    },
    "contracts/tokenWrappers/BaseTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../utils/UUPSHelper.sol\";\n\ninterface IDistributionCreator {\n    function distributor() external view returns (address);\n    function feeRecipient() external view returns (address);\n}\n\nabstract contract BaseMerklTokenWrapper is UUPSHelper, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    // ================================= CONSTANTS =================================\n\n    IDistributionCreator public constant DISTRIBUTOR_CREATOR =\n        IDistributionCreator(0x8BB4C975Ff3c250e0ceEA271728547f3802B36Fd);\n\n    address public immutable DISTRIBUTOR = DISTRIBUTOR_CREATOR.distributor();\n    address public immutable FEE_RECIPIENT = DISTRIBUTOR_CREATOR.feeRecipient();\n\n    // ================================= VARIABLES =================================\n\n    /// @notice `Core` contract handling access control\n    ICore public core;\n\n    // =================================== EVENTS ==================================\n\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    // ================================= MODIFIERS =================================\n\n    /// @notice Checks whether the `msg.sender` has the governor role or the guardian role\n    modifier onlyGovernor() {\n        if (!core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    // ================================= FUNCTIONS =================================\n\n    function token() public view virtual returns (address);\n\n    function isTokenWrapper() external pure returns (bool) {\n        return true;\n    }\n\n    function initialize(ICore _core) public initializer onlyProxy {\n        __ERC20_init(\n            string.concat(\"Merkl Token Wrapper - \", IERC20Metadata(token()).name()),\n            string.concat(\"mtw\", IERC20Metadata(token()).symbol())\n        );\n        __UUPSUpgradeable_init();\n        if (address(_core) == address(0)) revert ZeroAddress();\n        core = _core;\n    }\n\n    /// @notice Recovers any ERC20 token\n    /// @dev Governance only, to trigger only if something went wrong\n    function recoverERC20(address tokenAddress, address to, uint256 amountToRecover) external onlyGovernor {\n        IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal view override onlyGovernorUpgrader(core) {}\n}\n"
    },
    "contracts/tokenWrappers/RadiantTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { BaseMerklTokenWrapper } from \"./BaseTokenWrapper.sol\";\n\ninterface IVesting {\n    function rdntToken() external view returns (address);\n    function vestTokens(address, uint256, bool) external;\n}\n\n/// @title Radiant MTW\n/// @dev This token can only be held by merkl distributor\n/// @dev Transferring to the distributor will require transferring the underlying token to this contract\n/// @dev Transferring from the distributor will trigger vesting action\n/// @dev Transferring token to the distributor is permissionless so anyone could mint this wrapper - the only\n/// impact would be to forfeit these tokens\ncontract RadiantMerklTokenWrapper is BaseMerklTokenWrapper {\n    using SafeERC20 for IERC20;\n\n    // ================================= CONSTANTS =================================\n\n    IVesting public constant VESTING = IVesting(0x76ba3eC5f5adBf1C58c91e86502232317EeA72dE);\n    address internal immutable _UNDERLYING = VESTING.rdntToken();\n\n    // ================================= FUNCTIONS =================================\n\n    function token() public view override returns (address) {\n        return _UNDERLYING;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        // Needs an RDNT approval beforehand, this is how mints of coupons are done\n        if (to == DISTRIBUTOR) {\n            IERC20(_UNDERLYING).safeTransferFrom(from, address(this), amount);\n            _mint(from, amount); // These are then transferred to the distributor\n        }\n\n        // Will be burn right after, to avoid having any token aside from on the distributor\n        if (to == FEE_RECIPIENT) {\n            IERC20(_UNDERLYING).safeTransferFrom(from, FEE_RECIPIENT, amount);\n            _mint(from, amount); // These are then transferred to the fee manager\n        }\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (to == FEE_RECIPIENT) {\n            _burn(to, amount); // To avoid having any token aside from on the distributor\n        }\n\n        if (from == DISTRIBUTOR) {\n            _burn(to, amount);\n\n            // Vesting logic\n            IERC20(_UNDERLYING).transfer(address(VESTING), amount);\n            VESTING.vestTokens(to, amount, true);\n        }\n    }\n\n    function overrideNameAndSymbol() public onlyGovernor {\n        _name = string.concat(\"Merkl Token Wrapper - \", IERC20Metadata(token()).name());\n        _symbol = string.concat(\"mtw\", IERC20Metadata(token()).symbol());\n    }\n}\n"
    },
    "contracts/tokenWrappers/StakedToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC4626, ERC20 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\n// Cooldown logic forked from: https://github.com/aave/aave-stake-v2/blob/master/contracts/stake/StakedTokenV3.sol\ncontract StakedToken is ERC4626 {\n    uint256 public immutable COOLDOWN_SECONDS;\n    uint256 public immutable UNSTAKE_WINDOW;\n\n    mapping(address => uint256) public stakerCooldown;\n\n    error InsufficientCooldown();\n    error InvalidBalanceOnCooldown();\n    error UnstakeWindowFinished();\n\n    event Cooldown(address indexed sender, uint256 timestamp);\n\n    // ================================= FUNCTIONS =================================\n\n    constructor(\n        IERC20 asset_,\n        string memory name_,\n        string memory symbol_,\n        uint256 cooldownSeconds,\n        uint256 unstakeWindow\n    ) ERC4626(asset_) ERC20(name_, symbol_) {\n        COOLDOWN_SECONDS = cooldownSeconds;\n        UNSTAKE_WINDOW = unstakeWindow;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        if (from == address(0)) {\n            // For a mint: we update the cooldown of the receiver if needed\n            stakerCooldown[to] = getNextCooldownTimestamp(0, amount, to, balanceOf(to));\n        } else if (to == address(0)) {\n            uint256 cooldownEndTimestamp = stakerCooldown[from] + COOLDOWN_SECONDS;\n            if (block.timestamp <= cooldownEndTimestamp) revert InsufficientCooldown();\n            if (block.timestamp > cooldownEndTimestamp + UNSTAKE_WINDOW) revert UnstakeWindowFinished();\n        } else if (from != to) {\n            uint256 previousSenderCooldown = stakerCooldown[from];\n            stakerCooldown[to] = getNextCooldownTimestamp(previousSenderCooldown, amount, to, balanceOf(to));\n            // if cooldown was set and whole balance of sender was transferred - clear cooldown\n            if (balanceOf(from) == amount && previousSenderCooldown != 0) {\n                stakerCooldown[from] = 0;\n            }\n        }\n    }\n\n    function getNextCooldownTimestamp(\n        uint256 fromCooldownTimestamp,\n        uint256 amountToReceive,\n        address toAddress,\n        uint256 toBalance\n    ) public view returns (uint256 toCooldownTimestamp) {\n        toCooldownTimestamp = stakerCooldown[toAddress];\n        if (toCooldownTimestamp == 0) return 0;\n\n        uint256 minimalValidCooldownTimestamp = block.timestamp - COOLDOWN_SECONDS - UNSTAKE_WINDOW;\n\n        if (minimalValidCooldownTimestamp > toCooldownTimestamp) {\n            toCooldownTimestamp = 0;\n        } else {\n            fromCooldownTimestamp = (minimalValidCooldownTimestamp > fromCooldownTimestamp)\n                ? block.timestamp\n                : fromCooldownTimestamp;\n\n            if (fromCooldownTimestamp >= toCooldownTimestamp) {\n                toCooldownTimestamp =\n                    (amountToReceive * fromCooldownTimestamp + toBalance * toCooldownTimestamp) /\n                    (amountToReceive + toBalance);\n            }\n        }\n    }\n\n    function cooldown() external {\n        if (balanceOf(msg.sender) != 0) revert InvalidBalanceOnCooldown();\n        stakerCooldown[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender, block.timestamp);\n    }\n}\n"
    },
    "contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n\nerror CampaignDoesNotExist();\nerror CampaignAlreadyExists();\nerror CampaignDurationBelowHour();\nerror CampaignRewardTokenNotWhitelisted();\nerror CampaignRewardTooLow();\nerror CampaignSouldStartInFuture();\nerror InvalidDispute();\nerror InvalidLengths();\nerror InvalidParam();\nerror InvalidParams();\nerror InvalidProof();\nerror InvalidUninitializedRoot();\nerror InvalidReward();\nerror InvalidSignature();\nerror NoDispute();\nerror NotGovernor();\nerror NotGovernorOrGuardian();\nerror NotSigned();\nerror NotTrusted();\nerror NotWhitelisted();\nerror UnresolvedDispute();\nerror ZeroAddress();\n"
    },
    "contracts/utils/UUPSHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.17;\n\nimport { UUPSUpgradeable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { ICore } from \"../interfaces/ICore.sol\";\nimport \"../utils/Errors.sol\";\n\n/// @title UUPSHelper\n/// @notice Helper contract for UUPSUpgradeable contracts where the upgradeability is controlled by a specific address\n/// @author Angle Labs., Inc\n/// @dev The 0 address check in the modifier allows the use of these modifiers during initialization\nabstract contract UUPSHelper is UUPSUpgradeable {\n    modifier onlyGuardianUpgrader(ICore _core) {\n        if (address(_core) != address(0) && !_core.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    modifier onlyGovernorUpgrader(ICore _core) {\n        if (address(_core) != address(0) && !_core.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    constructor() initializer {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "viaIR": false,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}